	.symlen 6
	SUBTTL	Common file for BASIC interpreter
	.SALL

CONTO	defl 15	; CHARACTER TO SUPRESS OUTPUT (USUALLY CONTROL-O)
DBLTRN	defl 0	; FOR DOUBLE PRECISION TRANSCENDENTALS
	IF2

	.printx	/EXTENDED/


	.printx	/LPT/

	.printx	/CPM DISK/


	.printx	/Z80/

	.printx	/FAST/

	.printx	/5.0 FEATURES/

	.printx	/ANSI COMPATIBLE/
	ENDIF

CLMWID	defl 14	; MAKE COMMA COLUMNS FOURTEEN CHARACTERS
DATPSC	defl 128	; NUMBER OF DATA BYTES IN DISK SECTOR
LINLN	defl 80	; TERMINAL LINE LENGTH
LPTLEN	defl 132
BUFLEN	defl 255	; LONG LINES
NAMLEN	defl 40	; MAXIMUM LENGTH NAME -- 3 TO 127

NUMLEV	defl 0*20+19+2*5	; NUMBER OF STACK LEVELS RESERVED
			; BY AN EXPLICIT CALL TO GETSTK

STRSIZ	defl 4

STRSIZ	defl 3
NUMTMP	defl 3	; NUMBER OF STRING TEMPORARIES

NUMTMP	defl 10

MD.RND	defl 3	; THE MODE NUMBER FOR RANDOM FILES
MD.SQI	defl 1	; THE MODE NUMBER FOR SEQUENTIAL INPUT FILES
			; NEVER WRITTEN INTO A FILE
MD.SQO	defl 2	; THE MODE FOR SEQUENTIAL OUTPUT FILES
			; AND PROGRAM FILES
CPMWRM	defl 0	; CP/M WARM BOOT ADDR
CPMENT	defl CPMWRM+5	; CP/M BDOS CALL ADDR
	CSEG
TRUROM	defl 0
	PAGE
	TITLE	BIEDIT BASIC Interpreter EDIT routines/PGA etc.
	SUBTTL	EDIT COMMAND
;
;
;[C] CONTAINS COUNT OF CHARACTERS IN LINE
;[B] CONTAINS CURRENT CHARACTER POSITION 0=FIRST IN LINE.
;[D] CONTAINS NUMBER OF TIMES TO REPEAT THIS SUBCOMMAND
;[H,L] POINT TO CURRENT CHARACTER
;
;*
	PUBLIC	ERREDT,EDIT,EDITRT,POPART
	EXTRN	BUF,BUFLIN,CRDO,DOT,EDENT,ERRFLG,FININL,FNDLIN,INCHRI,OUTCH1
	EXTRN	LINPRT,LINSPC,LISPRT,MAKUPS,OUTDO,POPHRT,READY,USERR
	EXTRN	BLTUC,ERRLIN
ERREDT:	ld	(ERRFLG),a	; RESET THE FLAG TO CALL EDIT
	ld	hl,(ERRLIN)	; GET THE LINE NUMBER
	or	h	; SEE IF IT WAS DIRECT
	and	l
	inc	a	; SET ZERO FLAG ON DIRECT
	ex	de,hl		; LINE NUMBER INTO [D,E]
	ret	z		; GO BACK IF DIRECT
	jp	EREDIT
EDIT:	call	LINSPC	; GET THE ARGUMENT LINE NUMBER
	ret	nz		; ERROR IF NOT END OF LINE
EREDIT:	pop	hl	; GET RID OF NEWSTT ADDRESS
EEDITS:	ex	de,hl		; SAVE CURRENT LINE IN DOT
	ld	(DOT),hl	; FOR LATER EDIT OR LIST
	ex	de,hl		; GET BACK LINE # IN [H,L]
	call	FNDLIN	; FIND THE LINE IN QUESTION
	jp	nc,USERR	; IF NOT FOUND, UNDEFINED STATEMENT ERROR.
	ld	h,b	; PONTER TO LINE IS IN [B,C]
	ld	l,c	; TRANSFER IT TO [H,L]
	inc	hl	; PASS OVER POINTER TO NEXT LINE
	inc	hl	; LIKE SO.
	ld	c,(hl)	; GET FIRST BYTE OF LINE #
	inc	hl	; MOVE TO 2ND BYTE
	ld	b,(hl)	; PICK IT UP INTO B
	inc	hl	; ADVANCE TO POINT TO FIRST BYTE OF LINE
	push	bc	; SAVE LINE # ON STACK
	call	BUFLIN	; UNPACK LINE INTO BUF
	PUBLIC	INLED
LLED:	pop	hl	; GET BACK LINE #
INLED:	push	hl	; SAVE IT BACK ON STACK
	ld	a,h	; TEST FOR DOUBLE BYTE ZERO
	and	l
	inc	a
	ld	a,'!'	; GET PROMPT FOR DIRECT EDIT
	call	z,OUTDO	; SEND IT
	call	nz,LINPRT	; PRINT LINE # IF NOT INLIN EDIT
	ld	a,' '	; TYPE A SPACE
	call	OUTDO	; ...
	ld	hl,BUF	; GET START OF BUF IN [H,L]
	push	hl	; SAVE [H,L] WHILE WE CALC LINE LENGTH
	ld	c,255	; ASSUME 0 CHAR LINE
LENLP:	inc	c	; BUMP COUNT OF CHARS
	ld	a,(hl)	; GET CHAR FROM LINE
	inc	hl	; BUMP POINTER
	or	a
	jp	nz,LENLP	; IF NOT ZERO (END OF LINE) KEEP COUNTING...
	pop	hl	; GET BACK POINTER TO LINE
	ld	b,a	; SET CURRENT LINE POSIT TO ZERO
DISPED:	ld	d,0	; ASSUME REPITION COUNT IS ZERO
DISPI:	
	call	INCHRI	; GET A CHAR FROM USER
	or	a	; IGNORE NULLS
	jp	z,DISPI
	call	MAKUPS	; MAKE UPPER CASE COMMAND
	sub	'0'	; GET RID OF OFFSET
	jp	c,NOTDGI	; ...
	cp	10
	jp	nc,NOTDGI
	ld	e,a	; SAVE CHAR
	ld	a,d	; GET ACCUM REPITITION
	rlca		; MULTIPLY BY 2
	rlca		; BY 4
	add	a,d	; AND ADD TO GET 5*D
	rlca		; *2 TO GET 10*D
	add	a,e	; ADD DIGIT
	ld	d,a	; SAVE BACK NEW ACCUM
	jp	DISPI	; GET NEXT CHAR

NOTDGI:	push	hl	; SAVE TEXT POINTER
	ld	hl,DISPED	; PUT RETURN ADDRESS TO DISPED
	ex	(sp),hl		; ON THE STACK
	dec	d	; SEE IF D=0 (REP FACTOR)
	inc	d	; SET CONDITION CODES
	jp	nz,NTZERD	; BRANCH AROUND
	inc	d	; MAKE IT 1
NTZERD:	
	cp	8-'0'	; Backspace?
	jp	z,BAKED	; HANDLE IT
	cp	7fh-'0'	; DEL?
	jp	z,DELED	; BACKSPACE POINTER
	cp	13-'0'	; CARRIAGE RETURN
	jp	z,CRED	; DONE EDITING
	cp	' '-'0'	; SPACE
	jp	z,SPED	; GO TO ROUTINE
	cp	20h	; COMMAND IN LOWER CASE?
	jp	c,NOTLW4	; NO, SO OK.
	sub	20h	; CONVERT TO UPPER CASE
NOTLW4:	cp	'Q'-'0'	; QUIT?
	jp	z,QED	; IF SO, QUIT & PRINT "OK" OR RETURN TO INLIN
	cp	'L'-'0'	; L?
	jp	z,LED	; BRANCH
	cp	'S'-'0'	; S?
	jp	z,SED	; SEARCH
	cp	'I'-'0'	; I?
	jp	z,IED	; INSERT
	cp	'D'-'0'	; D?
	jp	z,DED	; DELETE
	cp	'C'-'0'	; C?
	jp	z,CED	; CHANGE
	cp	'E'-'0'	; END?
	jp	z,EED	; (SAME AS <CR> BUT DOESNT PRINT REST)
	cp	'X'-'0'	; EXTEND?
	jp	z,XED	; GO TO END OF LINE & INSERT
	cp	'K'-'0'	; KILL??
	jp	z,KED	; (SAME AS "S" BUT DELETES CHARS)
	cp	'H'-'0'	; HACK??
	jp	z,HED	; HACK OFF THE REST OF THE LINE & INSERT
	cp	'A'-'0'	; AGAIN??
	ld	a,7	; GET READY TO TYPE BEL.
	jp	nz,OUTDO	; NO MATCH, SEND BEL AND RETURN TO DISPATCHER
	pop	bc	; DISPI RETURN ADDRESS
	pop	de	; LINE NUMBER INTO [D,E]
	call	CRDO	; TYPE A CARRIAGE RETURN LINE-FEED
	jp	EEDITS	; RESTART EDITING

SPED:	ld	a,(hl)	; GET CHAR FROM CURENT POSIT
	or	a	; ARE WE AT END OF LINE?
	ret	z		; IF SO, RETURN
	inc	b	; BUMP CURRENT POSITION
	call	OUTCH1	; TYPE CHARACTER
	inc	hl	; MOVE POINTER TO NEXT CHAR
	dec	d	; TEST IF DONE WITH REPITITIONS
	jp	nz,SPED	; REPEAT
	ret		; RETURN TO DISPATCHER

KED:	push	hl	; SAVE CURRENT CHAR POSIT
	ld	hl,TYPSLH	; TYPE SLASH WHEN DONE
	ex	(sp),hl		; PUT IT ON STACK & GET POSIT BACK
	scf		; SET THE CARRY FLAG
SED:	push	af	; SAVE CONDITION CODES
	call	INCHRI	; GET SEARCH CHAR
	ld	e,a	; SAVE IT
	pop	af
	push	af
	call	c,TYPSLH	; TYPE BEGINNING SLASH FOR "K"
SRCALP:	ld	a,(hl)
	or	a
	jp	z,POPART
	call	OUTCH1	; TYPE THE CHAR
	pop	af	; GET KILL FLAG
	push	af	; SAVE BACK
	call	c,DELCHR	; DELETE THE CHAR IF K COMMAND.
	jp	c,NOTSRC	; AND DONT MOVE POINTER AS DELCHR ALREADY DID
	inc	hl
	inc	b	; INCREMENT LINE POSIT
NOTSRC:	ld	a,(hl)	; ARE WE AT END
	cp	e	; ARE CURRENT CHAR & SEARCH
	jp	nz,SRCALP	; CHAR THE SAME? IF NOT, LOOK MORE
	dec	d	; LOOK FOR N MATCHES
	jp	nz,SRCALP	; IF NOT 0, KEEP LOOKING

POPART:	pop	af	; GET RID OF KILL FLAG
	ret		; DONE SEARCHING
LED:	call	LISPRT	; TYPE REST OF LINE
	call	CRDO	; TYPE CARRIAGE RETURN
	pop	bc	; GET RID OF RETURN TO DISPED
	jp	LLED	; GO TO MAIN CODE

DED:	ld	a,(hl)	; GET CHAR WHICH WE ARE TRYING TO DELETE
	or	a	; IS IT THE END OF LINE MARKER?
	ret	z		; DONE IF SO
	ld	a,'\'	; TYPE BACKSLASH
	call	OUTCH1	; LIKE SO
DELLP:	ld	a,(hl)	; GET CHAR FROM LINE
	or	a	; ARE WE AT END?
	jp	z,TYPSLH	; TYPE SLASH
	call	OUTCH1	; TYPE CHAR WE'RE GOING TO DELETE
	call	DELCHR	; DELETE CURRENT CHAR
	dec	d	; DECREMENT DELETE COUNT
	jp	nz,DELLP	; KEEP DOING IT
TYPSLH:	
	ld	a,'\'	; TYPE ENDING SLASH
	call	OUTDO	; LIKE SO
	ret

CED:	ld	a,(hl)	; ARE WE AT END OF LINE?
	or	a	; SEE IF 0
	ret	z		; RETURN
CED2:	call	INCHRI	; GET CHAR TO REPLACE CHAR
	cp	32	; IS IT CONTROL CHAR?
	jp	nc,NOTCCC	; NO
	cp	10	; IS IT LF?
	jp	z,NOTCCC	; YES
	cp	7	; OR BELL?
	jp	z,NOTCCC	; OK
	cp	9	; OR TAB?
	jp	z,NOTCCC	; OK
	ld	a,7	; GET BELL
	call	OUTDO	; SEND IT
	jp	CED2	; RETRY
NOTCCC:	ld	(hl),a	; SAVE IN MEMORY
	call	OUTCH1	; ECHO THE CHAR WERE USING TO REPLACE
	inc	hl	; BUMP POINTER
	inc	b	; INCREMENT POSITION WITHIN LINE
	dec	d	; ARE WE DONE CHANGING?
	jp	nz,CED	; IF NOT, CHANGE SOME MORE.
	ret		; DONE
HED:	ld	(hl),0	; MAKE LINE END AT CURRENT POSITION
	ld	c,b	; SET UP LINE LENGTH CORRECTLY

XED:	ld	d,255	; FIND END OF LINE
	call	SPED	; BY CALLING SPACER
;NOW FALL INTO INSERT CODE
IED:	
	call	INCHRI	; GET CHAR TO INSERT

	cp	7fh	; DELETE??
	jp	z,TYPARW	; YES, ACT LIKE "_"
	cp	8	; Backspace?
	jp	z,TYPAR1	; Do delete
	cp	0dh	; IS IT A CARRIAGE RETURN?
	jp	z,CRED	; DONT INSERT, AND SIMULATE <CR>
	cp	1bh	; IS IT ESCAPE?
	ret	z		; IF SO, DONE.
	cp	8	; BACKSPACE?
	jp	z,TYPAR1	; TYPE BACKARROW AND DELETE
	cp	10	; LINE FEED?
	jp	z,NTARRW	; ALLOW IT
	cp	7	; BELL?
	jp	z,NTARRW	; ALLOW IT
	cp	9	; TAB?
	jp	z,NTARRW	; ALLOW IT
	cp	32	; IS IT ILLEGAL CHAR
	jp	c,IED	; TOO SMALL
	cp	'_'	; DELETE PREVIOUS CHAR INSERTED?
	jp	nz,NTARRW	; IF NOT, JUMP AROUND NEXT CODE
TYPARW:	
	ld	a,'_'	; TYPE IT
TYPAR1:	dec	b	; ARE WE AT START OF LINE?
	inc	b	; LETS SEE
	jp	z,DINGI	; IF SO, TYPE DING.
	call	OUTCH1	; TYPE THE BACK ARROW
	dec	hl	; BACK UP THE POINTER
	dec	b	; MOVE BACK POSIT IN LINE
	ld	de,IED	; SET UP RETURN ADDRESS
	push	de	; SAVE IT ON STACK & FALL THROUGH
; SUBROUTINE TO DELETE CHAR POINTED TO BY [H,L]. CORRECTS C.
DELCHR:	push	hl	; SAVE CURRENT POSIT POINTER
	dec	c	; MAKE LENGTH OF LINE ONE LESS
CMPRSS:	ld	a,(hl)	; GET CHAR TO DELETE
	or	a	; ARE WE AT END OF LINE
	scf		; FLAG THAT DELCHR WAS CALLED (FOR K)
	jp	z,POPHRT	; IF SO, DONE COMPRESSING
	inc	hl	; POINT TO NEXT BYTE
	ld	a,(hl)	; PICK IT UP
	dec	hl	; NOW BACK AGAIN
	ld	(hl),a	; DEPOSIT IT
	inc	hl	; NOW TO NEXT BYTE
	jp	CMPRSS	; KEEP CRUNCHING
NTARRW:	push	af	; SAVE THE CHAR TO BE INSERTED
	ld	a,c	; GET LENGTH OF LINE
	cp	BUFLEN	; SEE IF WE ARENT TRYING TO MAKE LINE TOO LONG
	jp	c,OKINS	; IF LENGTH OK, GO INSERT
	pop	af	; GET THE UNLAWFUL CHAR
DINGI:	
	ld	a,7	; TYPE A BELL TO LET USER KNOW
	call	OUTDO	; IT ALL OVER
IEDG:	jp	IED	; HE HAS TO TYPE <ESC> TO GET OUT
OKINS:	sub	b	; CALC POINTER TO 0 AT END OF LINE
	inc	c	; WE ARE GOING TO HAVE LINE LONGER BY 1
	inc	b	; POSITION MOVES UP ONE ALSO
	push	bc	; SAVE [B,C]
	ex	de,hl		; SAVE [D,E] IN [H,L]
	ld	l,a	; SAVE # OF BYTES TO MOVE IN [L]
	ld	h,0	; GET SET TO ADD [D,E] TO [H,L]
	add	hl,de	; CALC HIGH POINTER
	ld	b,h	; GET HIGH BYTE TO MOVE POINTER
	ld	c,l	; IN [B,C]
	inc	hl	; ALWAYS MOVE AT LEAST ZERO AT END
	call	BLTUC	; MOVE LINE OUT 1 CHAR
	pop	bc	; RESTORE [B,C]
	pop	af	; GET CHAR BACK
	ld	(hl),a	; SAVE IT IN LINE
	call	OUTCH1	; TYPE THE CHAR
	inc	hl	; POINT TO NEXT CHAR
	jp	IEDG	; AND GO GET MORE CHARS

BAKED:	ld	a,b	; ARE WE MOVING BACK PAST THE
	or	a	; FIRST CHARACTER
	ret	z		; DON'T ALLOW IT
	dec	hl	; MOVE CHAR POINTER BACK
	ld	a,8
	call	OUTCH1	; ECHO IT
	dec	b	; CHANGE CURRENT POSITION
	dec	d	; ARE WE DONE MOVING BACK?
	jp	nz,DELED	; IF NOT, GO BACK MORE
	ret		; RETURN

DELED:	ld	a,b	; ARE WE MOVING BACK PAST THE
	or	a	; FIRST CHARACTER
	ret	z		; DON'T ALLOW IT
	dec	b	; CHANGE CURRENT POSITION
	dec	hl	; MOVE CHAR POINTER BACK
	ld	a,(hl)	; GET CURRENT CHAR
	call	OUTCH1	; ECHO IT
	dec	d	; ARE WE DONE MOVING BACK?
	jp	nz,DELED	; IF NOT, GO BACK MORE
	ret		; RETURN

CRED:	call	LISPRT	; TYPE REST OF LINE
EED:	call	CRDO	; TYPE CARRIAGE RETURN
	pop	bc	; GET RID OF DISPED ADDRESS
	pop	de	; GET LINE # OFF STACK
	ld	a,d	; DOUBLE BYTE ZERO.
	and	e
	inc	a	; SET ZERO IF [D,E] = ALL ONES.
EDITRT:			; USED BY AUTO CODE
	ld	hl,BUF-1	; START KRUNCHING AT BUF
	ret	z		; RETURN TO INLIN IF CALLED FROM THERE
	scf		; FLAG LINE # WAS SEEN TO FOOL INSERT CODE
	push	af	; PSW IS ON STACK
	inc	hl	; NOW POINT AT BUF.
	jp	EDENT	; GO TO ENTRY POINT IN MAIN CODE

QED:	pop	bc	; GET RID OF DISPED ADDRESS
	pop	de	; GET LINE # OFF STACK
	ld	a,d	; DOUBLE BYTE ZERO.
	and	e
	inc	a	; SET ZERO IF [D,E] = ALL ONES.
	jp	z,FININL	; TYPE CR AND STORE ZERO IN BUF.
	jp	READY	; OTHERWISE CALLED FROM MAIN
	end

