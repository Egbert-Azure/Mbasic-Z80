	.symlen 6
	SUBTTL	Common file for BASIC interpreter
	.SALL

CONTO	defl 15	; CHARACTER TO SUPRESS OUTPUT (USUALLY CONTROL-O)
DBLTRN	defl 0	; FOR DOUBLE PRECISION TRANSCENDENTALS
	IF2

	.printx	/EXTENDED/


	.printx	/LPT/

	.printx	/CPM DISK/


	.printx	/Z80/

	.printx	/FAST/

	.printx	/5.0 FEATURES/

	.printx	/ANSI COMPATIBLE/
	ENDIF

CLMWID	defl 14	; MAKE COMMA COLUMNS FOURTEEN CHARACTERS
DATPSC	defl 128	; NUMBER OF DATA BYTES IN DISK SECTOR
LINLN	defl 80	; TERMINAL LINE LENGTH
LPTLEN	defl 132
BUFLEN	defl 255	; LONG LINES
NAMLEN	defl 40	; MAXIMUM LENGTH NAME -- 3 TO 127

NUMLEV	defl 0*20+19+2*5	; NUMBER OF STACK LEVELS RESERVED
			; BY AN EXPLICIT CALL TO GETSTK

STRSIZ	defl 4

STRSIZ	defl 3
NUMTMP	defl 3	; NUMBER OF STRING TEMPORARIES

NUMTMP	defl 10

MD.RND	defl 3	; THE MODE NUMBER FOR RANDOM FILES
MD.SQI	defl 1	; THE MODE NUMBER FOR SEQUENTIAL INPUT FILES
			; NEVER WRITTEN INTO A FILE
MD.SQO	defl 2	; THE MODE FOR SEQUENTIAL OUTPUT FILES
			; AND PROGRAM FILES
CPMWRM	defl 0	; CP/M WARM BOOT ADDR
CPMENT	defl CPMWRM+5	; CP/M BDOS CALL ADDR
	CSEG
TRUROM	defl 0
	PAGE
	TITLE	BIPTRG BASIC Interpreter pointer get routines/WHG/PGA
	SUBTTL	DIMENSION & VARIABLE SEARCHING - PTRGET
	EXTRN	ARYTA2,ARYTAB,BLTU,DIMFLG,ERRBS,ERROR,FAC,FCERR
	EXTRN	FACLO,GETSTK,INTIDX,ISLET,ISLET2,OMERR,REASON,SNERR,STREND
	EXTRN	SUBFLG,TEMP2,TEMP3,UMULT,VALTYP,VARTAB,REDDY,POPHRT,ERRDD,RETVAR
	EXTRN	CHRGTR,DCOMPR,SYNCHR
	EXTRN	GETYPR
	EXTRN	NAMBUF,NAMCNT,NAMTMP
	EXTRN	OPTVAL
	EXTRN	PARM1,PRMFLG,PRMLEN,DEFTBL,NOFUNS
	PUBLIC	PTRGET,BSERR,PTRGT2,DIM,NOARYS
DIMCON:	dec	hl	; SEE IF COMMA ENDED THIS VARIABLE
	call	CHRGTR
	ret	z		; IF TERMINATOR, GOOD BYE
	call	SYNCHR
	defb	44	; MUST BE COMMA
;
; THE "DIM" CODE SETS DIMFLG AND THEN FALLS INTO THE VARIABLE
; SEARCH ROUTINE. THE VARIABLE SEARCH ROUTINE LOOKS AT
; DIMFLG AT THREE DIFFERENT POINTS:
;
;	1) IF AN ENTRY IS FOUND, DIMFLG BEING ON INDICATES
;		A "DOUBLY DIMENSIONED" VARIABLE
;	2) WHEN A NEW ENTRY IS BEING BUILT DIMFLG'S BEING ON
;		INDICATES THE INDICES SHOULD BE USED FOR
;		THE SIZE OF EACH INDICE. OTHERWISE THE DEFAULT
;		OF TEN IS USED.
;	3) WHEN THE BUILD ENTRY CODE FINISHES, ONLY IF DIMFLG IS
;		OFF WILL INDEXING BE DONE
;
DIM:	ld	bc,DIMCON	; PLACE TO COME BACK TO
	push	bc
	defb	00f6h	; "ORI" NON ZERO THING
			; MUST TURN THE MSB ON
;
; ROUTINE TO READ THE VARIABLE NAME AT THE CURRENT TEXT POSITION
; AND PUT A POINTER TO ITS VALUE IN [D,E]. [H,L] IS UPDATED
; TO POINT TO THE CHARACTER AFTER THE VARIABLE NAME.
; VALTYP IS SETUP. NOTE THAT EVALUATING SUBSCRIPTS IN
; A VARIABLE NAME CAN CAUSE RECURSIVE CALLS TO PTRGET SO AT
; THAT POINT ALL VALUES MUST BE STORED ON THE STACK.
; ON RETURN, [A] DOES NOT REFLECT THE VALUE OF THE TERMINATING CHARACTER
;
PTRGET:	xor	a	; MAKE [A]=0
	ld	(DIMFLG),a	; FLAG IT AS SUCH
	ld	c,(hl)	; GET FIRST CHARACTER IN [C]
PTRGT2:	call	ISLET	; CHECK FOR LETTER
	jp	c,SNERR	; MUST HAVE A LETTER
	xor	a
	ld	b,a	; ASSUME NO SECOND CHARACTER
	ld	(NAMCNT),a	; ZERO NAMCNT
	inc	hl	; INCRMENT TEXT POINTER
	ld	a,(hl)	; GET CHAR
	cp	'.'	; IS IT A DOT?
	jp	c,NOSEC	; TOO SMALL FOR ANYTHING REASONABLE
	jp	z,ISSEC	; "." IS VALID VAR CHAR
	cp	'9'+1	; TOO BIG FOR NUMERIC?
	jp	nc,PTRGT3	; YES
	cp	'0'	; IN RIGHT RANGE?
	jp	nc,ISSEC	; YES, WAS NUMERIC
PTRGT3:	call	ISLET2	; SET CARRY IF NOT ALPHABETIC
	jp	c,NOSEC	; ALLOW ALPHABETICS
ISSEC:	ld	b,a	; IT IS A NUMBER--SAVE IN B
	push	bc	; SAVE [B,C]
	ld	b,255	; [B] COUNTS THE CHARACTERS PAST #2
	ld	de,NAMBUF-1	; THE PLACE TO PUT THE CHARACTERS
VMORCH:	or	128	; EXTRA CHARACTERS MUST HAVE THE HIGH BIT ON
			; SO ERASE CAN SCAN BACKWARDS OVER THEM
	inc	b	; INCREASE THE CHACRACTER COUNT
	ld	(de),a	; AND STORE INTO THE BUFFER
	inc	de	; AND UPDATE THE BUFFER POINTER
	inc	hl	; INCREMENT TEXT POINTER
	ld	a,(hl)	; GET CHAR
	cp	'9'+1	; TOO BIG?
	jp	nc,VMORC1	; YES
	cp	'0'	; IN RANGE FOR DIGIT
	jp	nc,VMORCH	; YES, VALID CHAR
VMORC1:	call	ISLET2	; AS ARE ALPHABETICS
	jp	nc,VMORCH
	cp	'.'	; DOTS ALSO OK
	jp	z,VMORCH	; SO EAT IT
	ld	a,b	; CHECK FOR MAXIMUM COUNT
	cp	NAMLEN-1	; LIMITED TO SIZE OF NAMBUF ONLY
	jp	nc,SNERR	; MUST BE BAD SYNTAX
	pop	bc	; GET BACK THE STORED [B,C]
	ld	(NAMCNT),a	; ALWAYS SET UP COUNT OF EXTRAS
	ld	a,(hl)	; RESTORE TERMINATING CHAR
NOSEC:	
	cp	'%'+1	; NOT A TYPE INDICATOR
	jp	nc,TABTYP	; THEN DONT CHECK THEM
	ld	de,HAVTYP	; SAVE JUMPS BY USING RETURN ADDRESS
	push	de
	ld	d,2	; CHECK FOR INTEGER
	cp	'%'
	ret	z
	inc	d	; CHECK FOR STRING
	cp	'$'
	ret	z
	inc	d	; CHECK FOR SINGLE PRECISION
	cp	'!'
	ret	z
	ld	d,8	; ASSUME ITS DOUBLE PRECISION
	cp	'#'	; CHECK THE CHARACTER
	ret	z		; WHEN WE MATCH, SETUP VALTYP
	pop	af	; POP OFF NON-USED HAVTYP ADDRESS
TABTYP:	ld	a,c	; GET THE STARTING CHARACTER
	and	127	; GET RID OF THE USER-DEFINED
			; FUNCTION BIT IN [C]
	ld	e,a	; BUILD A TWO BYTE OFFSET
	ld	d,0
	push	hl	; SAVE THE TEXT POINTER
	ld	hl,DEFTBL-'A'	; SEE WHAT THE DEFAULT IS
	add	hl,de
	ld	d,(hl)	; GET THE TYPE OUT OF THE TABLE
	pop	hl	; GET BACK THE TEXT POINTER
	dec	hl	; NO MARKING CHARACTER
HAVTYP:	ld	a,d	; SETUP VALTYP
	ld	(VALTYP),a
	call	CHRGTR	; READ PAST TYPE MARKER
	ld	a,(SUBFLG)	; GET FLAG WHETHER TO ALLOW ARRAYS
	dec	a	; IF SUBFLG=1, "ERASE" HAS CALLED
	jp	z,ERSFIN	; PTRGET, AND SPECIAL HANDLING MUST BE DONE
	jp	p,NOARYS	; NO ARRAYS ALLOWED
	ld	a,(hl)	; GET CHAR BACK
	sub	'('	; ARRAY PERHAPS (IF SUBFLG SET NEVER WILL MATCH)
	jp	z,ISARY	; IT IS!
	sub	'['-')'+1	; SEE IF LEFT BRACKET
	jp	z,ISARY	; IF SO, OK SUBSCRIPT
NOARYS:	xor	a	; ALLOW PARENS AGAIN
	ld	(SUBFLG),a	; SAVE IN FLAG LOCATION
	push	hl	; SAVE THE TEXT POINTER
	ld	a,(NOFUNS)	; ARE FUNCTIONS ACTIVE?
	or	a
	ld	(PRMFLG),a	; INDICATE IF PARM1 NEEDS SEARCHING
	jp	z,SNFUNS	; NO FUNCTIONS SO NO SPECIAL SEARCH
	ld	hl,(PRMLEN)	; GET THE SIZE TO SEARCH
	ld	de,PARM1	; GET THE BASE OF THE SEARCH
	add	hl,de	; [H,L]= PLACE TO STOP SEARCHING
	ld	(ARYTA2),hl	; SET UP STOPPING POINT
	ex	de,hl		; [H,L]=START [D,E]=END
	jp	LOPFND	; START LOOPING
LOPTOP:	ld	a,(de)	; GET THE VALTYP OF THIS SIMPLE VARIABLE
	ld	l,a	; SAVE SO WE KNOW HOW MUCH TO SKIP
	inc	de
	ld	a,(de)	; [A]=FIRST CHARACTER OF THIS VARIABLE
	inc	de	; POINT TO 2ND CHAR OF VAR NAME
	cp	c	; SEE IF OUR VARIABLE MATCHES
	jp	nz,NOTIT1
	ld	a,(VALTYP)	; GET TYPE WERE LOOKING FOR
	cp	l	; COMPARE WITH OUR VALTYP
	jp	nz,NOTIT1	; NOT RIGHT KIND -- SKIP IT
	ld	a,(de)	; SEE IF SECOND CHACRACTER MATCHES
	cp	b
	jp	z,FINPTR	; THAT WAS IT, ALL DONE
NOTIT1:	inc	de
NFINPT:	ld	a,(de)	; GET LENGTH OF VAR NAME IN [A]
SNOMAT:	
			; SKIP OVER THE
			; CURRENT VARIABLE SINCE WE DIDN'T MATCH
	ld	h,0	; [H,L]=NUMBER OF BYTES TO SKIP
	add	a,l	; ADD VALTYPE TO LENGTH OF VAR
	inc	a	; PLUS ONE
	ld	l,a	; SAVE IN [L] TO MAKE OFFSET
	add	hl,de	; ADD ON THE POINTER
LOPFND:	ex	de,hl		; [D,E]=POINTER INTO SIMPLE VARIABLES
	ld	a,(ARYTA2)	; ARE LOW BYTES DIFFERENT
	cp	e	; TEST
	jp	nz,LOPTOP	; YES
	ld	a,(ARYTA2+1)	; ARE HIGH BYTES DIFFERENT
	cp	d	; THE SAME?
	jp	nz,LOPTOP	; NO, MUST BE MORE VARS TO EXAMINE

NOTFNS:	ld	a,(PRMFLG)	; HAS PARM1 BEEN SEARCHED
	or	a
	jp	z,SMKVAR	; IF SO, CREATE VARIABLE
	xor	a	; FLAG PARM1 AS SEARCHED
	ld	(PRMFLG),a
SNFUNS:	ld	hl,(ARYTAB)	; STOPPING POINT IS [ARYTA2]
	ld	(ARYTA2),hl
	ld	hl,(VARTAB)	; SET UP STARTING POINT
	jp	LOPFND

; THIS IS EXIT FOR VARPTR AND OTHERS
VARNOT:	
	ld	d,a	; ZERO [D,E]
	ld	e,a
	pop	bc	; GET RID OF PUSHED [D,E]
	ex	(sp),hl		; PUT RETURN ADDRESS BACK ON STACK
	ret		; RETURN FROM PTRGET

SMKVAR:	pop	hl	; [H,L]= TEXT POINTER
	ex	(sp),hl		; [H,L]= RETURN ADDRESS
	push	de	; SAVE CURRENT VARIABLE TABLE POSITION
	EXTRN	VARRET
	ld	de,VARRET	; ARE WE RETURNING TO VARPTR?
	call	DCOMPR	; COMPARE
	jp	z,VARNOT	; YES.
	EXTRN	COMPTR,COMPT2	; RETURN HERE IF NOT FOUND
	ld	de,COMPTR
	call	DCOMPR
	jp	z,VARNOT
	ld	de,COMPT2	; 2ND ONE
	call	DCOMPR
	jp	z,VARNOT
	ld	de,RETVAR	; DID EVAL CALL US?
	call	DCOMPR	; IF SO, DON'T MAKE A NEW VARIABLE
	pop	de	; RESTORE THE POSITION
	jp	z,FINZER	; MAKE FAC ZERO (ALL TYPES) AND SKIP RETURN
	ex	(sp),hl		; PUT RETURN ADDRESS BACK
	push	hl	; PUT THE TEXT POINTER BACK
	push	bc	; SAVE THE LOOKS
	ld	a,(VALTYP)	; GET LENGTH OF SYMBOL TABLE ENTRY
	ld	b,a	; [B]=VALTYP
	ld	a,(NAMCNT)	; INCLUDE EXTRA CHARACTERS IN SIZE
	add	a,b
	inc	a	; AS WELL AS THE EXTRA CHARACTER COUNT
	ld	c,a	; [B,C]=LENGTH OF THIS VARIABLE
	push	bc	; SAVE THE VALTYP ON THE STACK
	ld	b,0	; [B]=0
	inc	bc	; MAKE THE LENGTH INCLUDE
			; THE LOOKS TOO
	inc	bc
	inc	bc
			; EVERYTHING UP BY
	ld	hl,(STREND)	; THE CURRENT END OF STORAGE
	push	hl	; SAVE THIS #
	add	hl,bc	; ADD ON THE AMOUNT OF SPACE
			; EXTRA NOW BEING USED
	pop	bc	; POP OFF HIGH ADDRESS TO MOVE
	push	hl	; SAVE NEW CANDIDATE FOR STREND
	call	BLTU	; BLOCK TRANSFER AND MAKE SURE
			; WE ARE NOT OVERFLOWING THE
			; STACK SPACE
	pop	hl	; [H,L]=NEW STREND
	ld	(STREND),hl	; STORE SINCE WAS OK
			; THERE WAS ROOM, AND BLOCK TRANSFER
			; WAS DONE, SO UPDATE POINTERS
	ld	h,b	; GET BACK [H,L] POINTING AT THE END
	ld	l,c	; OF THE NEW VARIABLE
	ld	(ARYTAB),hl	; UPDATE THE ARRAY TABLE POINTER
ZEROER:	dec	hl	; [H,L] IS RETURNED POINTING TO THE
	ld	(hl),0	; END OF THE VARIABLE SO WE
	call	DCOMPR	; ZERO BACKWARDS TO [D,E] WHICH
	jp	nz,ZEROER	; POINTS TO THE START OF THE VARIABLE
	pop	de	; [E]=VALTYP
	ld	(hl),d	; VALTYP IS IN HIGH ORDER
	inc	hl
	pop	de
	ld	(hl),e	; PUT DESCRIPTION
	inc	hl
	ld	(hl),d	; OF THIS VARIABLE
			; INTO MEMORY
	call	NPUTSB	; SAVE THE EXTRA CHARACTERS IN THE NAME
	ex	de,hl		; POINTER AT VARIABLE INTO [D,E]
	inc	de	; POINT AT THE VALUE
	pop	hl	; RESTORE THE TEXT POINTER
	ret
FINPTR:	inc	de	; POINT AT THE EXTRA CHARACTER COUNT
	ld	a,(NAMCNT)	; SEE IF THE EXTRA COUNTS MATCH
	ld	h,a	; SAVE LENGTH OF NEW VAR
	ld	a,(de)	; GET LENGTH OF CURRENT VAR
	cp	h	; ARE THEY THE SAME?
	jp	nz,NFINPT	; SKIP EXTRAS AND CONTINUE SEARCH
	or	a	; LENGTH ZERO?
	jp	nz,NTFPRT	; NO, MORE CHARS TO LOOK AT
	inc	de	; POINT TO VALUE OF VAR
	pop	hl	; RESTORE TEXT POINTER
	ret		; ALL DONE WITH THIS VAR
NTFPRT:	ex	de,hl
	call	MATSUB	; SEE IF THE CHARACTERS MATCH
	ex	de,hl		; TABLE POINTER BACK INTO [D,E]
	jp	nz,SNOMAT	; IF NOT, CONTINUE SEARCH
	pop	hl	; GET BACK THE TEXT POINTER
	ret
;
; MAKE ALL TYPES ZERO AND SKIP RETURN
;
FINZER:	
	ld	(FAC),a	; MAKE SINGLES AND DOUBLES ZERO
	ld	h,a	; MAKE INTEGERS ZERO
	ld	l,a
	ld	(FACLO),hl
	call	GETYPR	; SEE IF ITS A STRING
	jp	nz,POPHR2	; IF NOT, DONE
	ld	hl,REDDY-1	; MAKE IT A NULL STRING BY
	ld	(FACLO),hl	; POINTING AT A ZERO
POPHR2:	pop	hl	; GET THE TEXT POINTER
	ret		; RETURN FROM EVAL


	PAGE
	SUBTTL	MULTIPLE DIMENSION CODE

;
; FORMAT OF ARRAYS IN CORE
;
; DESCRIPTOR 
;	LOW BYTE = SECOND CHARCTER (200 BIT IS STRING FLAG)
;	HIGH BYTE = FIRST CHARACTER
; LENGTH OF ARRAY IN CORE IN BYTES (DOES NOT INCLUDE DESCRIPTOR)
; NUMBER OF DIMENSIONS 1 BYTE
; FOR EACH DIMENSION STARTING WITH THE FIRST A LIST
; (2 BYTES EACH) OF THE MAX INDICE+1
; THE VALUES
;
ISARY:	push	hl	; SAVE DIMFLG AND VALTYP FOR RECURSION
	ld	hl,(DIMFLG)
	ex	(sp),hl		; TEXT POINTER BACK INTO [H,L]
	ld	d,a	; SET # DIMENSIONS =0
INDLOP:	push	de	; SAVE NUMBER OF DIMENSIONS
	push	bc	; SAVE LOOKS
	ld	de,NAMCNT	; POINT AT THE AREA TO SAVE
	ld	a,(de)	; GET LENGTH
	or	a	; IS IT ZERO?
	jp	z,SHTNAM	; YES, SHORT NAME
	ex	de,hl		; SAVE THE TEXT POINTER IN [D,E]
	add	a,2	; WE WANT SMALLEST INT .GE.(NAMCNT+1)/2
	rra
	ld	c,a	; SEE IF THERE IS ROOM TO SAVE THIS STUFF
	call	GETSTK
	ld	a,c	; RESTORE COUNT OF PUSHES
LPPSNM:	ld	c,(hl)	; GET VALUES TO PUSH
	inc	hl
	ld	b,(hl)
	inc	hl
	push	bc	; AND DO THE SAVE
	dec	a	; [A] TIMES
	jp	nz,LPPSNM
	push	hl	; SAVE THE ADDRESS TO STORE TO
	ld	a,(NAMCNT)	; SAVE THE NUMBER OF BYTES FOR A COUNT
	push	af
	ex	de,hl		; RESTORE THE TEXT POINTER
	call	INTIDX	; EVALUATE INDICE INTO [D,E]
	pop	af	; COUNT TELLING HOW MUCH TO RESTORE
	ld	(NAMTMP),hl	; SAVE THE TEXT POINTER
	pop	hl	; THE PLACE TO RESTORE TO
	add	a,2	; CALCULATE BYTE POPS AGAIN
	rra
LPLNAM:	pop	bc
	dec	hl
	ld	(hl),b
	dec	hl
	ld	(hl),c
	dec	a	; LOOP [A] TIMES POPING NAME BACK INTO NAMBUF
	jp	nz,LPLNAM
	ld	hl,(NAMTMP)
	jp	LNGNAM	; WAS LONG ONE
SHTNAM:	call	INTIDX	; EVALUATE IT
	xor	a	; MAKE SURE NAMCNT=0
	ld	(NAMCNT),a
LNGNAM:	
	ld	a,(OPTVAL)	; SEE WHAT THE OPTION BASE IS
	or	a
	jp	z,OPTB0	; IF BASE 0 DO NOTHING
	ld	a,d	; CHECK FOR 0 SUBSCRIPT
	or	e	; WHICH IS ILLEGAL IN BASE 1
	dec	de	; ADJUST SUBSCRIPT
	jp	z,BSERR
OPTB0:	
	pop	bc	; POP OFF THE LOOKS
	pop	af	; [A] = NUMBER OF DIMENSIONS SO FAR
	ex	de,hl		; [D,E]=TEXT POINTER
			; [H,L]=INDICE
	ex	(sp),hl		; PUT THE INDICE ON THE STACK
			; [H,L]=VALTYP & DIMFLG
	push	hl	; RESAVE VALTYP AND DIMFLG
	ex	de,hl		; [H,L]=TEXT POINTER
	inc	a	; INCREMENT # OF DIMENSIONS
	ld	d,a	; [D]=NUMBER OF DIMENSIONS
	ld	a,(hl)	; GET TERMINATING CHARACTER
	cp	44	; A COMMA SO MORE INDICES FOLLOW?
	jp	z,INDLOP	; IF SO, READ MORE
	cp	')'	; EXPECTED TERMINATOR?
	jp	z,DOCHRT	; DO CHRGET FOR NEXT ONE
	cp	']'	; BRACKET?
	jp	nz,SNERR	; NO, GIVE ERROR
DOCHRT:	call	CHRGTR
SUBSOK:	ld	(TEMP2),hl	; SAVE THE TEXT POINTER
	pop	hl	; [H,L]= VALTYP & DIMFLG
	ld	(DIMFLG),hl	; SAVE VALTYP AND DIMFLG
	ld	e,0	; WHEN [D,E] IS POPED INTO PSW, WE
			; DON'T WANT THE ZERO FLAG TO BE SET, SO
			; "ERASE" WILL HAVE A UNIQUE CONDITION
	push	de	; SAVE NUMBER OF DIMENSIONS
	PUBLIC	ERSFIN
	defb	11h	; "LXI D," OVER THE NEXT TWO BYTES
ERSFIN:	push	hl	; SAVE THE TEXT POINTER
	push	af	; SAVE A DUMMY NUMBER OF DIMENSIONS
			; WITH THE ZERO FLAG SET
;
; AT THIS POINT [B,C]=LOOKS. THE TEXT POINTER IS IN TEMP2.
; THE INDICES ARE ALL ON THE STACK, FOLLOWED BY THE NUMBER OF DIMENSIONS.
;
	ld	hl,(ARYTAB)	; [H,L]=PLACE TO START THE SEARCH
	defb	3eh	; "MVI A," AROUND THE NEXT BYTE
LOPFDA:	add	hl,de	; SKIP OVER THIS ARRAY SINCE IT'S
			; NOT THE ONE
	ex	de,hl		; [D,E]=CURRENT SEARCH POINT
	ld	hl,(STREND)	; GET THE PLACE TO STOP INTO [H,L]
	ex	de,hl		; [H,L]=SEARCH POINT
	call	DCOMPR	; STOPPING TIME?
	jp	z,NOTFDD	; YES, COULDN'T FIND THIS ARRAY
	ld	e,(hl)	; GET VALTYP IN [E]
	inc	hl
	ld	a,(hl)	; GET FIRST CHARACTER
	inc	hl
	cp	c	; SEE IF IT MATCHES
	jp	nz,NMARY1	; NOT THIS ONE
	ld	a,(VALTYP)	; GET TYPE OF VAR WERE LOOKING FOR
	cp	e	; SAME AS THIS ONE?
	jp	nz,NMARY1	; NO, SKIP THIS VAR
	ld	a,(hl)	; GET SECOND CHARACTER
	cp	b	; ANOTHER MATCH?
	jp	z,CMPNAM	; MATCH, CHECK OUT REST OF NAME
NMARY1:	inc	hl	; POINT TO SIZE ENTRY
BNAMSZ:	ld	e,(hl)	; GET VAR NAME LENGTH IN [E]
	inc	e	; ADD ONE TO GET CORRECT LENGTH
	ld	d,0	; HIGH BYTE OF ZERO
	add	hl,de	; ADD OFFSET
CNOMAT:	
	ld	e,(hl)	; [D,E]=LENGTH
	inc	hl	; OF THE ARRAY BEING LOOKED AT
	ld	d,(hl)
	inc	hl
	jp	nz,LOPFDA	; IF NO MATCH, SKIP THIS ONE
			; AND TRY AGAIN
	ld	a,(DIMFLG)	; SEE IF CALLED BY "DIM"
	or	a	; ZERO MEANS NO
	EXTRN	DDERR
	jp	nz,DDERR	; PRESERVE [D,E], AND DISPATCH TO
			; "REDIMENSIONED VARIABLE" ERROR
			; IF ITS "DIM" CALLING PTRGET
;
; TEMP2=THE TEXT POINTER
; WE HAVE LOCATED THE VARIABLE WE WERE LOOKING FOR
; AT THIS POINT [H,L] POINTS BEYOND THE SIZE TO THE NUMBER OF DIMENSIONS
; THE INDICES ARE ON THE STACK FOLLOWED BY THE NUMBER OF DIMENSIONS
;
	pop	af	; [A]=NUMBER OF DIMENSIONS
	ld	b,h	; SET [B,C] TO POINT AT NUMBER OF DIMENSIONS
	ld	c,l
	jp	z,POPHRT	; "ERASE" IS DONE AT THIS POINT, SO RETURN
			; TO DO THE ACTUAL ERASURE
	sub	(hl)	; MAKE SURE THE NUMBER GIVEN NOW AND
			; AND WHEN THE ARRAY WAS SET UP ARE THE
			; SAME
	jp	z,GETDEF	; JUMP OFF AND READ
			; THE INDICES....

BSERR:	ld	de,0+ERRBS	; "SUBSCRIPT OUT OF RANGE"
	jp	ERROR
CMPNAM:	inc	hl	; POINT TO LENGTH OF NAME
	ld	a,(NAMCNT)	; SEE IF COUNT MATCHES COUNT IN COMPLEX TABLE
	cp	(hl)
	jp	nz,BNAMSZ	; BAD NAME SIZE JUST SKIP AND SET NZ CC
	inc	hl	; POINT ONE BYTE AFTER LENGTH FIELD
	or	a	; LENGTH ZERO?
	jp	z,CNOMAT	; THEN FOUND, EXIT
	dec	hl	; MOVE BACK ONE
	call	MATSUB	; OTHERWISE TRY TO MATCH CHARACTERS
	jp	CNOMAT	; USING COMMON SUBROUTINE
;
; HERE WHEN VARIABLE IS NOT FOUND IN THE ARRAY TABLE
;
; BUILDING AN ENTRY:
; 
;	PUT DOWN THE DESCRIPTOR	
;	SETUP NUMER OF DIMENSIONS
;	MAKE SURE THERE IS ROOM FOR THE NEW ENTRY
;	REMEMBER VARPTR
;	TALLY=4 (VALTYP FOR THE EXTENDED)
;	SKIP 2 LOCS FOR LATER FILL IN -- THE SIZE
; LOOP:	GET AN INDICE
;	PUT NUMBER +1 DOWN AT VARPTR AND INCREMENT VARPTR
;	TALLY= TALLY * NUMBER+1
;	DECREMENT NUMBER-DIMS
;	JNZ	LOOP
;	CALL REASON WITH [H,L] REFLECTING LAST LOC OF VARIABLE
;	UPDATE STREND
;	ZERO BACKWARDS
;	MAKE TALLY INCLUDE MAXDIMS
;	PUT DOWN TALLY
;	IF CALLED BY DIMENSION, RETURN
;	OTHERWISE INDEX INTO THE VARIABLE AS IF IT
;	WERE FOUND ON THE INITIAL SEARCH
;
NOTFDD:	
	ld	a,(VALTYP)	; GET VALTYP OF NEW VAR
	ld	(hl),a	; PUT DOWN THE VARIABLE TYPE
	inc	hl
	ld	e,a
	ld	d,0	; [D,E]=SIZE OF ONE VALUE (VALTYP)
	pop	af	; [A]=NUMBER OF DIMENSIONS
	jp	z,PTRRNZ	; CALLED BY CHAIN, JUST RETURN NON-ZERO
	ld	(hl),c	; PUT DOWN THE DESCRIPTOR
	inc	hl
	ld	(hl),b
	call	NPUTSB	; STORE THE EXTRA CHARACTERS IN THE TABLE
	inc	hl
	ld	c,a	; [C]=NUMBER OF TWO BYTE ENTRIES NEEDED
			; TO STORE THE SIZE OF EACH DIMENSION
	call	GETSTK	; GET SPACE FOR DIMENSION ENTRIES
	inc	hl	; SKIP OVER THE SIZE LOCATIONS
	inc	hl
	ld	(TEMP3),hl	; SAVE THE LOCATION TO PUT THE SIZE
			; IN -- POINTS AT THE NUMBER OF DIMENSIONS
	ld	(hl),c	; STORE THE NUMBER OF DIMENSIONS
	inc	hl
	ld	a,(DIMFLG)	; CALLED BY DIMENSION?
	rla		; SET CARRY IF SO
	ld	a,c	; [A]=NUMBER OF DIMENSIONS
LOPPTA:	
	jp	c,POPDIM
	push	af
	ld	a,(OPTVAL)	; GET THE OPTION BASE
	xor	11	; MAP 0 TO 11 AND 1 TO 10
	ld	c,a	; [B,C]=DEFAULT DIMENSION
	ld	b,0
	pop	af
	jp	nc,NOTDIM	; DEFAULT DIMENSIONS TO TEN
POPDIM:	pop	bc	; POP OFF AN INDICE INTO [B,C]
	inc	bc	; ADD ONE TO IT FOR THE ZERO ENTRY
NOTDIM:	ld	(hl),c	; PUT THE MAXIMUM DOWN
	push	af	; SAVE THE NUMBER OF DIMENSIONS AND
			; DIMFLG (CARRY)
	inc	hl
	ld	(hl),b
	inc	hl
	call	UMULT	; MULTIPLY [B,C]=NEWMAX BY CURTOL=[D,E]
	pop	af	; GET THE NUMBER OF DIMENSIONS AND
			; DIMFLG (CARRY) BACK
	dec	a	; DECREMENT THE NUMBER OF DIMENSIONS LEFT
	jp	nz,LOPPTA	; HANDLE THE OTHER INDICES
	push	af	; SAVE DIMFLG (CARRY)
	ld	b,d	; [B,C]=SIZE
	ld	c,e
	ex	de,hl		; [D,E]=START OF VALUES
	add	hl,de	; [H,L]=END OF VALUES
	jp	c,OMERR	; OUT OF MEMORY POINTER BEING GENERATED?
	call	REASON	; SEE IF THERE IS ROOM FOR THE VALUES
	ld	(STREND),hl	; UPDATE THE END OF STORAGE
ZERITA:	dec	hl	; ZERO THE NEW ARRAY
	ld	(hl),0
	call	DCOMPR	; BACK AT THE BEGINNING?
	jp	nz,ZERITA	; NO, ZERO MORE
	inc	bc	; ADD ONE TO THE SIZE TO INCLUDE
			; THE BYTE FOR THE NUMBER OF DIMENSIONS
	ld	d,a	; [D]=ZERO
	ld	hl,(TEMP3)	; GET A POINTER AT THE NUMBER OF DIMENSIONS
	ld	e,(hl)	; [E]=NUMBER OF DIMENSIONS
	ex	de,hl		; [H,L]=NUMBER OF DIMENSIONS
	add	hl,hl	; [H,L]=NUMBER OF DIMENSIONS TIMES TWO
	add	hl,bc	; ADD ON THE SIZE
			; TO GET THE TOTAL NUMBER OF BYTES USED
	ex	de,hl		; [D,E]=TOTAL SIZE
	dec	hl	; BACK UP TO POINT TO LOCATION TO PUT
	dec	hl	; THE SIZE OF THE ARRAY IN BYTES IN.
	ld	(hl),e	; PUT DOWN THE SIZE
	inc	hl
	ld	(hl),d
	inc	hl
	pop	af	; GET BACK DIMFLG (CARRY) AND SET [A]=0
	jp	c,FINNOW
;
; AT THIS POINT [H,L] POINTS BEYOND THE SIZE TO THE NUMBER OF DIMENSIONS
; STRATEGY:
;	NUMDIM=NUMBER OF DIMENSIONS
;	CURTOL=0
; INLPNM:GET A NEW INDICE
;	POP NEW MAX INTO CURMAX
;	MAKE SURE INDICE IS NOT TOO BIG
;	MUTLIPLY CURTOL BY CURMAX
;	ADD INDICE TO CURTOL
;	NUMDIM=NUMDIM-1
;	JNZ	INLPNM
;	USE CURTOL*4 (VALTYP FOR EXTENDED) AS OFFSET
;
GETDEF:	ld	b,a	; [B,C]=CURTOL=ZERO
	ld	c,a
	ld	a,(hl)	; [A]=NUMBER OF DIMENSIONS
	inc	hl	; POINT PAST THE NUMBER OF DIMENSIONS
	defb	0016h	; "MVI D," AROUND THE NEXT BYTE
INLPNM:	pop	hl	; [H,L]= POINTER INTO VARIABLE ENTRY
	ld	e,(hl)	; [D,E]=MAXIMUM FOR THE CURRENT INDICE
	inc	hl
	ld	d,(hl)
	inc	hl
	ex	(sp),hl		; [H,L]=CURRENT INDICE
			; POINTER INTO THE VARIABLE GOES ON THE STACK
	push	af	; SAVE THE NUMBER OF DIMENSIONS
	call	DCOMPR	; SEE IF THE CURRENT INDICE IS TOO BIG
	jp	nc,BSERR	; IF SO "BAD SUBSCRIPT" ERROR
	call	UMULT	; CURTOL=CURTOL*CURRENT MAXIMUM
	add	hl,de	; ADD THE INDICE TO CURTOL
	pop	af	; GET THE NUMBER OF DIMENSIONS IN [A]
	dec	a	; SEE IF ALL THE INDICES HAVE BEEN PROCESSED
	ld	b,h	; [B,C]=CURTOL IN CASE WE LOOP BACK
	ld	c,l
	jp	nz,INLPNM	; PROCESS THE REST OF THE INDICES
	ld	a,(VALTYP)	; SEE HOW BIG THE VALUES ARE
			; AND MULTIPLY BY THAT SIZE
	ld	b,h	; SAVE THE ORIGINAL VALUE FOR MULTIPLYING
	ld	c,l	; BY THREE
	add	hl,hl	; MULTIPLY BY TWO AT LEAST
	sub	4	; FOR INTEGERS AND STRINGS
			; NO MORE MULTIPLYING BY TWO
	jp	c,SMLVAL
	add	hl,hl	; NOW MULTIPLIED BY FOUR
	jp	z,DONMUL	; IF SINGLE ALL DONE
	add	hl,hl	; BY EIGHT FOR DOUBLES
SMLVAL:	
	or	a	; FIX CC'S FOR Z-80
	jp	po,DONMUL	; FOR STRINGS
	add	hl,bc	; ADD IN THE ORIGINAL
DONMUL:	
	pop	bc	; POP OFF THE ADDRESS OF WHERE THE VALUES
			; BEGIN
	add	hl,bc	; ADD IT ONTO CURTOL TO GET THE
			; PLACE THE VALUE IS STORED
	ex	de,hl		; RETURN THE POINTER IN [D,E]
FINNOW:	ld	hl,(TEMP2)	; REGET THE TEXT POINTER
	ret
PTRRNZ:	scf		; RETURN WITH NON-ZERO IN [A]
	sbc	a,a	; AND CONDITION CODES SET
	pop	hl	; RESTORE TEST POINTER
	ret

;
; LONG VARIABLE NAME SUBROUTINES. AFTER THE NORMAL 2 CHARACTER NAME
; THE COUNT OF ADDITIONAL CHARACTERS IS STORED. FOLLOWING THIS
; COMES THE CHARACTERS IN ORDER WITH THE HIGH BIT TURNED ON SO A BACKWARD
; SCAN IS POSSIBLE
;
	PUBLIC	IADAHL
IADAHL:	ld	a,(hl)	; GET THE CHARACTER COUNT
	inc	hl
ADDAHL:	push	bc	; ADD [A] TO [H,L]
	ld	b,0
	ld	c,a
	add	hl,bc
	pop	bc	; RESTORE THE SAVED [B,C]
	ret
NPUTSB:	push	bc	; THIS ROUTINE STORE THE "LONG" NAME AT [H,L]
	push	de
	push	af
	ld	de,NAMCNT	; POINT AT DATA TO SAVE
	ld	a,(de)	; GET THE COUNT
	ld	b,a
	inc	b	; [B]= NUMBER OF BYTES TO SAVE
SLPLNG:	ld	a,(de)	; FETCH STORE VALUE
	inc	de
	inc	hl	; MOVE UP TO STORE NAME INTO TABLE
	ld	(hl),a	; DO THE STORE
	dec	b	; AND REPEAT [B] TIMES
	jp	nz,SLPLNG	; FOR THE COUNT AND DATA
	pop	af
	pop	de
	pop	bc
	ret

MATSUB:	push	de	; THIS ROUTINE TRIES TO PERFORM A MATCH
	push	bc
	ld	de,NAMBUF	; POINT AT COUNT AND DATA
	ld	b,a	; [B]=CHARACTER COUNT
	inc	hl	; POINT AT THE DATA
	inc	b	; START OFF LOOP
SLPMAT:	dec	b	; MATCHED ALL CHARACTERS YET?
	jp	z,ISMAT2	; IF SO, ITS A MATCH
	ld	a,(de)	; GET ANOTHER CHARACTER
	cp	(hl)	; SEE IF ITS THE SAME
	inc	hl	; MOVE FORWARD IN DEFINITION TABLE
	inc	de	; MORE FORWARD IN STORED NAME
	jp	z,SLPMAT	; IF MATCH KEEP GOING UNTIL END
	ld	a,b	; NEED TO ADVANCE BY [B]-1 TO SKIP BAD CHARS
	dec	a
	call	nz,ADDAHL	; USE THE COMMON SUBROUTINE. [H,L]=[H,L]+[A]
	xor	a	; SET CC'S NON ZERO FOR NO MATCH
	dec	a	; AND RETURN [A]=FF
ISMAT2:	pop	bc	; RESTORE SAVED REGISTERS
	pop	de
	ret

	PAGE
	end

