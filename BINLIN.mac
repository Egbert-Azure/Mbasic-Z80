	.symlen 6
	SUBTTL	Common file for BASIC interpreter
	.SALL

CONTO	defl 15	; CHARACTER TO SUPRESS OUTPUT (USUALLY CONTROL-O)
DBLTRN	defl 0	; FOR DOUBLE PRECISION TRANSCENDENTALS
	IF2

	.printx	/EXTENDED/


	.printx	/LPT/

	.printx	/CPM DISK/


	.printx	/Z80/

	.printx	/FAST/

	.printx	/5.0 FEATURES/

	.printx	/ANSI COMPATIBLE/
	ENDIF

CLMWID	defl 14	; MAKE COMMA COLUMNS FOURTEEN CHARACTERS
DATPSC	defl 128	; NUMBER OF DATA BYTES IN DISK SECTOR
LINLN	defl 80	; TERMINAL LINE LENGTH
LPTLEN	defl 132
BUFLEN	defl 255	; LONG LINES
NAMLEN	defl 40	; MAXIMUM LENGTH NAME -- 3 TO 127

NUMLEV	defl 0*20+19+2*5	; NUMBER OF STACK LEVELS RESERVED
			; BY AN EXPLICIT CALL TO GETSTK

STRSIZ	defl 4

STRSIZ	defl 3
NUMTMP	defl 3	; NUMBER OF STRING TEMPORARIES

NUMTMP	defl 10

MD.RND	defl 3	; THE MODE NUMBER FOR RANDOM FILES
MD.SQI	defl 1	; THE MODE NUMBER FOR SEQUENTIAL INPUT FILES
			; NEVER WRITTEN INTO A FILE
MD.SQO	defl 2	; THE MODE FOR SEQUENTIAL OUTPUT FILES
			; AND PROGRAM FILES
CPMWRM	defl 0	; CP/M WARM BOOT ADDR
CPMENT	defl CPMWRM+5	; CP/M BDOS CALL ADDR
	CSEG
TRUROM	defl 0
	PAGE
	TITLE	INLIN BASIC Interpreter Input Line routine/WHG/PGA/MBM, etc.
	SUBTTL	INLIN - LINE INPUT ROUTINE
	PUBLIC	INLIN,QINLIN
	EXTRN	FININL
	EXTRN	BUF,CRDO,INCHR,OUTDO
	EXTRN	LISPRT
	EXTRN	CTRLPT


; THIS IS THE LINE INPUT ROUTINE
; IT READS CHARACTERS INTO BUF USING _ AS THE
; CHARACTER DELETE CHARACTER AND @ AS THE LINE DELETE CHARACTER
; IF MORE THAN BUFLEN CHARACTER ARE TYPED, NO ECHOING
; IS DONE UNTIL A  _ @ OR CARRIAGE-RETURN IS TYPED.
; CONTROL-G WILL BE TYPED FOR EACH EXTRA CHARACTER.
; THE ROUTINE IS ENTERED AT INLIN, AT QINLIN TO TYPE A QUESTION MARK
; AND A SPACE FIRST

QINLIN:	ld	a,'?'	; GET A QMARK
	call	OUTDO	; TYPE IT
	ld	a,' '	; SPACE
	call	OUTDO	; TYPE IT TOO
	jp	INLIN	; NO CRUNCHING IN THIS CASE
INLINC:	call	INCHR	; GET A CHAR
	cp	1	; CONTROL A?
	jp	nz,INLNC1	; NO, TREAT NORMALLY
	ld	(hl),0	; SAVE TERMINATOR
	jp	INLED1	; GO EDIT FROM HERE

INLINQ:	ld	(hl),b	; STORE ZERO IN BUF
INLIN:	
	xor	a	; CLEAR TYPE AHEAD CHAR
	EXTRN	CHARC
	ld	(CHARC),a	; LIKE SO
	PUBLIC	SINLIN
	EXTRN	TEMPA
	xor	a
	ld	(TEMPA),a	; FLAG TO DO CR
SINLIN:	
			; SAVE CURRENT CURSOR ADDRESS (TTYPOS)
	call	INCHR	; GET CHAR
	cp	1	; CONTROL-A?
	jp	nz,INLINS	; GO DO IT
INLED1:	
	call	CRDO	; TYPE CRLF
	ld	hl,0+65535	; GET SPECIAL LINE #
	EXTRN	INLED
	jp	INLED	; GO TO EDIT CODE.
			; GET CHAR
RUBOUT:	
	EXTRN	RUBSW
	ld	a,(RUBSW)	; ARE WE ALREADY RUBBING OUT?
	or	a	; SET CC'S
	ld	a,'\'	; GET READY TO TYPE BACKSLASH
	ld	(RUBSW),a	; MAKE RUBSW NON-ZERO IF NOT ALREADY
	jp	nz,NOTBEG	; NOT RUBBING BACK TO BEGGINING
	dec	b	; AT BEGINNING OF LINE?
	jp	z,INLINQ	; SET FIRST BYTE IN BUF TO ZERO
	call	OUTDO	; SEND BACKSLASH
	inc	b	; EFFECTIVELY SKIP NEXT INSTRUCTION
NOTBEG:	dec	b	; BACK UP CHAR COUNT BY 1
	dec	hl	; AND LINE POSIT
	jp	z,INLINN	; AND RE-SET UP INPUT
	ld	a,(hl)	; OTHERWISE GET CHAR TO ECHO
	call	OUTDO	; SEND IT
	jp	INLINC	; AND GET NEXT CHAR

LINLIN:	dec	b	; BACK ARROW SO DECREMENT COUNT
LINLN2:	dec	hl	; BACK UP POINTER
	call	OUTDO
	jp	nz,INLINC	; NOT TOO MANY SO CONTINUE
INLINN:	call	OUTDO	; PRINT THE @, OR A SECOND _ IF THERE
			; WERE TOO MANY
INLINU:	call	CRDO	; TYPE A CRLF
INLINS:	ld	hl,BUF
	ld	b,1	; CHARACTER COUNT
	push	af
	xor	a	; ALWAYS CLEAR RUBOUT SWITCH
	ld	(RUBSW),a	; BY STORING IN
	pop	af
INLNC1:	
	ld	c,a	; SAVE CURRENT CHAR IN [C]
	cp	7fh	; CHARACTER DELETE?
	jp	z,RUBOUT	; DO IT
	ld	a,(RUBSW)	; BEEN DOING A RUBOUT?
	or	a	; SET CC'S
	jp	z,NOTRUB	; NOPE.
	ld	a,'\'	; GET READY TO TYPE SLASH
	call	OUTDO	; SEND IT
	xor	a	; CLEAR RUBSW
	ld	(RUBSW),a	; LIKE SO.
NOTRUB:	ld	a,c	; GET BACK CURRENT CHAR
	cp	7	; IS IT BOB ALBRECHT RINGING THE BELL
	jp	z,GOODCH	; FOR SCHOOL KIDS?
	cp	3	; CONTROL-C?

	call	z,CTRLPT	; TYPE ^ FOLLOWED BY CHAR, AND CRLF
	scf		; RETURN WITH CARRY ON
	ret	z		; IF IT WAS CONTROL-C
	cp	13	; IS IT A CARRIAGE RETURN?
	jp	z,GFNINL
	cp	9	; TAB?
	jp	z,GOODCH	; SAVE IT
	cp	10	; LF?
	jp	nz,CHKFUN	; NO, SEE IF FUNNY CHAR
	dec	b	; SEE IF ONLY CHAR ON LINE
	jp	z,INLIN	; IT IS, IGNORE
	inc	b	; RESTORE B
	jp	GOODCH	; IS LF AND NOT NULL LINE
CHKFUN:	
	cp	'U'-40h	; LINE DELETE? (CONTROL-U)
	call	z,CTRLPT	; PRINT ^U
	jp	z,INLIN
	cp	8	; BACKSPACE? (CONTROL-H)?
	jp	nz,NTBKSP	; NO
DRBKSP:	dec	b	; AT START OF LINE?
	jp	z,SINLIN
	call	OUTDO	; SEND BACKSPACE
	ld	a,' '	; SEND SPACE TO WIPE OUT CHAR
	call	OUTDO
	ld	a,8	; SEND ANOTHER BACKSPACE
	jp	LINLN2
NTBKSP:	
	cp	24	; IS IT CONTROL-X (LINE DELETE)
	jp	nz,NTCTLX	; NO
	ld	a,'#'	; SEND NUMBER SIGN
	jp	INLINN	; SEND # SIGN AND ECHO
NTCTLX:	
	cp	18	; CONTROL-R?
	jp	nz,NTCTLR	; NO
	push	bc	; SAVE [B,C]
	push	de	; SAVE [D,E]
	push	hl	; SAVE [H,L]
	ld	(hl),0	; STORE TERMINATOR
	call	CRDO	; DO CRLF
	ld	hl,BUF	; POINT TO START OF BUFFER
	call	LISPRT	; HANDLE LINE-FEEDS PROPERLY
	pop	hl	; RESTORE [H,L]
	pop	de	; RESTORE [D,E]
	pop	bc	; RESTORE [B,C]
	jp	INLINC	; GET NEXT CHAR
NTCTLR:	
	cp	32	; CHECK FOR FUNNY CHARACTERS
	jp	c,INLINC
			; PHILIPS MUST ECHO CONTROLS
GOODCH:	ld	a,b	; GET CURRENT LENGTH
			; *** SPECIAL CHECK IF BUFFER 255 LONG FOR LEN2
	inc	a	; BUMP LINE LENGTH
	EXTRN	PTRFIL,LINGET,CURLIN
	jp	nz,OUTBND	; NO CAUSE FOR BELL
	push	hl	; SAVE [H,L]
	ld	hl,(PTRFIL)	; SEE IF READING FROM DISK
	ld	a,h	; BY TESTING FOR PTRFIL
	or	l	; NON-ZERO
	pop	hl	; RESTORE [H,L]
	ld	a,7	; GET BELL CHAR
	jp	z,OUTBEL	; NOT READING FROM DISK, SEND BELL
	ld	hl,BUF	; MAKE [H,L] POINT TO BUFF
	call	LINGET	; GET LINE NUMBER
	ex	de,hl		; GET LINE # IN [H,L]
	ld	(CURLIN),hl	; SAVE IN CURRENT LINE #
	EXTRN	ERROR
	EXTRN	LBOERR
	jp	LBOERR	; GIVE LINE BUFFER OVERFLOW ERROR
OUTBND:	
	ld	a,c	; RESTORE CURRENT CHARACTER INTO [A]
	ld	(hl),c	; STORE THIS CHARACTER
	inc	hl	; BUMP POINTER INTO BUF
	inc	b	; INCREMENT CHARACTER COUNT
OUTBEL:	
	call	OUTDO	; SEND THE CHAR
			; SEND CHAR
	sub	10	; LF??
	jp	nz,INLINC	; NO, GET NEXT CHAR
	EXTRN	TTYPOS
	ld	(TTYPOS),a	; MAKE SURE TTYPOS=0.
			; MAKE SURE TTYPOS=0
	ld	a,13	; SEND CR.
	call	OUTDO	; BY CALLING OUTCHR
EATNUL:	call	INCHR	; EAT NEXT CHAR
	or	a	; NULL AFTER LF?
	jp	z,EATNUL	; DONT LET IT GET BY
	cp	13	; A CARRIAGE RETURN??
	jp	z,INLINC	; EAT IT & GET NEXT CHAR
	jp	INLNC1	; USE IT
			; MUST ECHO THE CHAR
	PAGE
	EXTRN	TEMPA
	PUBLIC	SCNSEM
	EXTRN	CHRGTR,BUFMIN
GFNINL:	
	ld	a,(TEMPA)	; DO CR OR NOT?
	or	a	; TEST
	jp	z,FININL	; YES
	xor	a	; MAKE ZERO
	ld	(hl),a	; STORE TERMINATOR
	ld	hl,BUFMIN	; GET POINTER TO START OF BUF
	ret		; DONE

SCNSEM:	push	af	; SAVE CHAR
	ld	a,0	; ASSUME NO SEMI
	ld	(TEMPA),a
	pop	af	; GET BACK CHAR
	cp	';'	; IS IT A SEMI?
	ret	nz		; NO
	ld	(TEMPA),a	; FLAG NO CR FROM INLIN
	jp	CHRGTR
	end

