	.symlen 6
	SUBTTL	Common file for BASIC interpreter
	.SALL

CONTO	defl 15	; CHARACTER TO SUPRESS OUTPUT (USUALLY CONTROL-O)
DBLTRN	defl 0	; FOR DOUBLE PRECISION TRANSCENDENTALS
	IF2

	.printx	/EXTENDED/


	.printx	/LPT/

	.printx	/CPM DISK/


	.printx	/Z80/

	.printx	/FAST/

	.printx	/5.0 FEATURES/

	.printx	/ANSI COMPATIBLE/
	ENDIF

CLMWID	defl 14	; MAKE COMMA COLUMNS FOURTEEN CHARACTERS
DATPSC	defl 128	; NUMBER OF DATA BYTES IN DISK SECTOR
LINLN	defl 80	; TERMINAL LINE LENGTH
LPTLEN	defl 132
BUFLEN	defl 255	; LONG LINES
NAMLEN	defl 40	; MAXIMUM LENGTH NAME -- 3 TO 127

NUMLEV	defl 0*20+19+2*5	; NUMBER OF STACK LEVELS RESERVED
			; BY AN EXPLICIT CALL TO GETSTK

STRSIZ	defl 4

STRSIZ	defl 3
NUMTMP	defl 3	; NUMBER OF STRING TEMPORARIES

NUMTMP	defl 10

MD.RND	defl 3	; THE MODE NUMBER FOR RANDOM FILES
MD.SQI	defl 1	; THE MODE NUMBER FOR SEQUENTIAL INPUT FILES
			; NEVER WRITTEN INTO A FILE
MD.SQO	defl 2	; THE MODE FOR SEQUENTIAL OUTPUT FILES
			; AND PROGRAM FILES
CPMWRM	defl 0	; CP/M WARM BOOT ADDR
CPMENT	defl CPMWRM+5	; CP/M BDOS CALL ADDR
	CSEG
TRUROM	defl 0
	PAGE
	TITLE	BISTRS BASIC Interpreter String routines/WHG/PGA etc.
	EXTRN	MOVRM
	EXTRN	ARYTAB,BLTUC,CONINT,CRFIN,DSCTMP,ERRLS,ERROR,ERRSO,ERRST
	EXTRN	EVAL,FACLO,FCERR,FOUT,FRETOP,FRMEQL,FRMEVL,FRMPRN
	EXTRN	GETBYT,MEMSIZ,OUTDO,POPHRT,PTRGET,SIGNS,SNERR
	EXTRN	STREND,TEMPPT,TEMPST,TSTOP,VALTYP,VARTAB,SNGFLT,TEMP8
	EXTRN	GIVDBL,FIN,ARYTA2,CHKSTR
	PUBLIC	LHSMID
	EXTRN	ARYTA2,FINDBL,GETBCD,PRMPRV,TEMP9,VMOVE
	EXTRN	GETYPR
	EXTRN	CHRGTR,DCOMPR,SYNCHR
	EXTRN	IADAHL
	PUBLIC	CHR$,STRPRT,STROUI,LEN,FRESTR,STRCMP,VAL,ASC,ASC2,STRLTI
	PUBLIC	STROUT,FRETMS,FRETMP,RIGHT$,LEFT$,GARBA2,STR$
	PUBLIC	FRE,STRLIT,STRCPY,CAT,STRLT3,MID$
	PUBLIC	STRINI,STRIN1,STRAD1,PUTDEI
;
; THE FOLLOWING ROUTINE COMPARES TWO STRINGS
; ONE WITH DESC IN [D,E] OTHER WITH DESC. IN [FACLO, FACLO+1]
; A=0 IF STRINGS EQUAL
; A=377 IF B,C,D,E .GT. FACLO
; A=1 IF B,C,D,E .LT. FACLO
;
STRCMP:	call	FRESTR	; FREE UP THE FAC STRING, AND GET THE
			; POINTER TO THE FAC DESCRIPTOR IN [H,L]
	ld	a,(hl)	; SAVE THE LENGTH OF THE FAC STRING IN [A]
	inc	hl
	ld	c,(hl)	; SAVE THE POINTER AT THE FAC STRING
			; DATA IN [B,C]
	inc	hl
	ld	b,(hl)
	pop	de	; GET THE STACK STRING POINTER
	push	bc	; SAVE THE POINTER AT THE FAC STRING DATA
	push	af	; SAVE THE FAC STRING LENGTH
	call	FRETMP	; FREE UP THE STACK STRING AND RETURN
			; THE POINTER TO THE STACK STRING DESCRIPTOR
			; IN [H,L]
	pop	de	; [D]=LENGTH OF FAC STRING
	ld	e,(hl)	; [E]=LENGTH OF STACK STRING
	inc	hl
	ld	c,(hl)	; [B,C]=POINTER AT STACK STRING
	inc	hl
	ld	b,(hl)
	pop	hl	; GET BACK 2ND CHARACTER POINTER
CSLOOP:	ld	a,e	; BOTH STRINGS ENDED
	or	d	; TEST BY OR'ING THE LENGTHS TOGETHER
	ret	z		; IF SO, RETURN WITH A ZERO
	ld	a,d	; GET FACLO STRING LENGTH
	sub	1	; SET CARRY AND MAKE [A]=255 IF [D]=0
	ret	c		; RETURN IF THAT STRING ENDED
	xor	a	; MUST NOT HAVE BEEN ZERO, TEST CASE
	cp	e	; OF B,C,D,E STRING HAVING ENDED FIRST
	inc	a	; RETURN WITH A=1
	ret	nc		; TEST THE CONDITION
;HERE WHEN NEITHER STRING ENDED
	dec	d	; DECREMENT BOTH CHARACTER COUNTS
	dec	e
	ld	a,(bc)	; GET CHARACTER FROM B,C,D,E STRING
	inc	bc
	cp	(hl)	; COMPARE WITH FACLO STRING
	inc	hl	; BUMP POINTERS (INX DOESNT CLOBBER CC'S)
	jp	z,CSLOOP	; IF BOTH THE SAME, MUST BE MORE TO STRINGS
	ccf		; HERE WHEN STRINGS DIFFER
	jp	SIGNS	; SET [A] ACCORDING TO CARRY
	SUBTTL	STRING FUNCTIONS
	EXTRN	FOUTO,FOUTH
	PUBLIC	STRO$,STRH$
; THE STRO$ FUNCTION TAKES A NUMBER AND GIVES
; A STRING WITH THE CHARACTERS THE NUMBER WOULD GIVE IF
; OUTPUT IN OCTAL
;
STRO$:	call	FOUTO	; PUT OCTAL NUMBER IN FBUFFR
	jp	STR$1	; JUMP INTO STR$ CODE

; STRH$ SAME AS STRO$ EXCEPT USES HEX INSTEAD OF OCTAL
STRH$:	call	FOUTH	; PUT HEX NUMBER IN FBUFFR
	jp	STR$1	; JUMP INTO STR$ CODE
;
; THE STR$ FUNCTION TAKES A NUMBER AND GIVES
; A STRING WITH THE CHARACTERS THE OUTPUT OF THE NUMBER
; WOULD HAVE GIVEN
;
STR$:	
			; IS A NUMERIC
	call	FOUT	; DO ITS OUTPUT
STR$1:	call	STRLIT	; SCAN IT AND TURN IT INTO A STRING
	call	FREFAC	; FREE UP THE TEMP
	ld	bc,FINBCK
	push	bc	; SET UP ANSWER IN NEW TEMP
;
; STRCPY CREATES A COPY OF THE STRING
; WHOSE DESCRIPTOR IS POINTED TO BY [H,L].
; ON RETURN [D,E] POINTS TO DSCTMP
; WHICH HAS THE STRING INFO (LENGTH,WHERE COPIED TO)
;
STRCPY:	ld	a,(hl)	; GET LENGTH
	inc	hl	; MOVE UP TO THE POINTER
	push	hl	; GET POINTER TO POINTER OF ARG
	call	GETSPA	; GET THE SPACE
	pop	hl	; FIND OUT WHERE STRING TO COPY
	ld	c,(hl)
	inc	hl
	ld	b,(hl)
	call	STRAD2	; SETUP DSCTMP
	push	hl	; SAVE POINTER TO DSCTMP
	ld	l,a	; GET CHARACTER COUNT INTO [L]
	call	MOVSTR	; MOVE THE CHARS IN
	pop	de	; RESTORE POINTER TO DSCTMP
	ret		; RETURN

STRIN1:	ld	a,1	; MAKE ONE CHAR STRING (CHR$, INKEY$)
STRINI:	call	GETSPA	; GET SOME STRING SPACE ([A] CHARS)
STRAD2:	ld	hl,DSCTMP	; GET DESC. TEMP
STRAD1:	push	hl	; SAVE DESC. POINTER
	ld	(hl),a	; SAVE CHARACTER COUNT
PUTDEI:	inc	hl	; STORE [D,E]=POINTER TO FREE SPACE
	ld	(hl),e
	inc	hl
	ld	(hl),d
	pop	hl	; AND RESTORE [H,L] AS THE DESCRIPTOR POINTER
	ret
;
; STRLT2 TAKES THE STRING LITERAL WHOSE FIRST CHARACTER
; IS POINTED BY [H,L]+1 AND BUILDS A DESCRIPTOR FOR IT.
; THE DESCRIPTOR IS INITIALLY BUILT IN DSCTMP, BUT PUTNEW
; TRANSFERS IT INTO A TEMPORARY AND LEAVES A POINTER
; AT THE TEMPORARY IN FACLO. THE CHARACTERS OTHER THAN
; ZERO THAT TERMINATE THE STRING SHOULD BE SET UP IN [B]
; AND [D]. IT THE TERMINATOR IS A QUOTE, THE QUOTE IS SKIPPED
; OVER. LEADING QUOTES SHOULD BE SKIPPED BEFORE CALL. ON RETURN
; THE CHARACTER AFTER THE STRING LITERAL IS POINTED TO
; BY [H,L] AND IS IN [A], BUT THE CONDITION CODES ARE
; NOT SET UP.
;
	PUBLIC	STRLT2
STRLIT:	dec	hl
STRLTI:	ld	b,34	; ASSUME STR ENDS ON QUOTE
STRLT3:	ld	d,b
STRLT2:	push	hl	; SAVE POINTER TO START OF LITERAL
	ld	c,255	; INITIALIZE CHARACTER COUNT
STRGET:	inc	hl
	ld	a,(hl)	; GET CHAR
	inc	c	; BUMP CHARACTER COUNT
	or	a	; IF 0, (END OF LINE) DONE
	jp	z,STRFIN	; TEST
	cp	d
	jp	z,STRFIN
	cp	b	; CLOSING QUOTE
	jp	nz,STRGET	; NO, GO BACK FOR MORE
STRFIN:	cp	34	; IF QUOTE TERMINATES THE STRING
	call	z,CHRGTR	; SKIP OVER THE QUOTE
	push	hl	; SAVE POINTER AT END OF STRING
	ld	a,b	; WERE WE SCANNING AN UNQUOTED STRING?
	cp	44
	jp	nz,NTTRLS	; IF NOT, DON'T SUPPRESS TRAILING SPACES
	inc	c	; FIX [C] WHICH IS THE CHARACTER COUNT
LPTRLS:	dec	c	; DECREMENT UNTIL WE FIND A NON-SPACE CHARACTER
	jp	z,NTTRLS	; DON'T GO PAST START (ALL SPACES)
	dec	hl	; LOOK AT PREVIOUS CHARACTER
	ld	a,(hl)
	cp	' '
	jp	z,LPTRLS	; IF SO CONTINUE LOOKING
NTTRLS:	pop	hl
	ex	(sp),hl
	inc	hl
	ex	de,hl		; GET POINTER TO TEMP
	ld	a,c	; GET CHARACTER COUNT IN A
	call	STRAD2	; SAVE STR INFO
;
; SOME STRING FUNCTION IS RETURNING A RESULT IN DSCTMP
; WE WANT TO SETUP A TEMP DESCRIPTOR WITH DCSTMP IN IT
; PUT A POINTER TO THE DESCRIPTOR IN FACLO AND FLAG THE 
; RESULT AS TYPE STRING
;
	PUBLIC	PUTNEW
PUTNEW:	ld	de,DSCTMP	; [D,E] POINT AT RESULT DESCRIPTOR
	PUBLIC	PUTTMP
	defb	003eh	; SKIP THE NEXT BYTE ("MVI AL,")
PUTTMP:	push	de	; SAVE A POINTER TO THE START OF THE STRING
	ld	hl,(TEMPPT)	; [H,L]=POINTER TO FIRST FREE TEMP
	ld	(FACLO),hl	; POINTER AT WHERE RESULT DESCRIPTOR WILL BE
	ld	a,3
	ld	(VALTYP),a	; FLAG THIS AS A STRING
	call	VMOVE	; AND MOVE THE VALUE INTO A TEMPORARY
	ld	de,DSCTMP+3	; IF THE CALL IS TO PUTTMP, [D,E]
			; WILL NOT EQUAL DSCTMP +3
	call	DCOMPR	; DSCTMP IS JUST BEYOND THE TEMPS
			; AND IF TEMPPT POINTS AT IT THERE
			; ARE NO FREE TEMPS
	ld	(TEMPPT),hl	; SAVE NEW TEMPORARY POINTER
	pop	hl	; GET THE TEXT POINTER
	ld	a,(hl)	; GET CURRENT CHARACTER INTO [A]
	ret	nz
	ld	de,0+ERRST	; "STRING TEMPORARY" ERROR
	jp	ERROR	; GO TELL HIM
;
; PRINT THE STRING POINTED TO BY [H,L] WHICH ENDS WITH A ZERO
; IF THE STRING IS BELOW DSCTMP IT WILL BE COPIED INTO STRING SPACE
;
STROUI:	inc	hl	; POINT AT NEXT CHARACTER
STROUT:	call	STRLIT	; GET A STRING LITERAL
;
; PRINT THE STRING WHOSE DESCRIPTOR IS POINTED TO BY FACLO.
;
STRPRT:	call	FREFAC	; RETURN TEMP POINTER BY FACLO
	call	GETBCD	; [D]=LENGTH [B,C]=POINTER AT DATA
	inc	d	; INCREMENT AND DECREMENT EARLY
			; TO CHECK FOR NULL STRING
STRPR2:	dec	d	; DECREMENT THE LENGTH
	ret	z		; ALL DONE
	ld	a,(bc)	; GET CHARACTER TO PRINT
	call	OUTDO
	cp	13
	call	z,CRFIN
	inc	bc	; POINT TO THE NEXT CHARACTER
	jp	STRPR2	; AND PRINT IT...
	PAGE
	SUBTTL	STRING GARBAGE COLLECTION - GETSPA, GARBAG
;
; GETSPA - GET SPACE FOR CHARACTER STRING
; MAY FORCE GARBAGE COLLECTION.
;
; # OF CHARS (BYTES) IN [A]
; RETURNS WITH POINTER IN [D,E] OTHERWISE IF CANT GET SPACE
; BLOWS OFF TO "OUT OF STRING SPACE" TYPE ERROR.
;
	PUBLIC	GETSPA
GETSPA:	or	a	; MUST BE NON ZERO. SIGNAL NO GARBAG YET
	defb	000eh	; "MVI C" AROUND THE NEXT BYTE
TRYGI2:	pop	af	; IN CASE COLLECTED WHAT WAS LENGTH?
	push	af	; SAVE IT BACK
	ld	hl,(STREND)
	ex	de,hl		; IN [D,E]
	ld	hl,(FRETOP)	; GET TOP OF FREE SPACE IN [H,L]
	cpl		; -# OF CHARS
	ld	c,a	; IN [B,C]
	ld	b,255
	add	hl,bc	; SUBTRACT FROM TOP OF FREE
	inc	hl
	call	DCOMPR	; COMPARE THE TWO
	jp	c,GARBAG	; NOT ENOUGH ROOM FOR STRING, OFFAL TIME
	ld	(FRETOP),hl	; SAVE NEW BOTTOM OF MEMORY
	inc	hl	; MOVE BACK TO POINT TO STRING
	ex	de,hl		; RETURN WITH POINTER IN [D,E]
	PUBLIC	PPSWRT
PPSWRT:	pop	af	; GET CHARACTER COUNT
	ret		; RETURN FROM GETSPA

GARBAG:	pop	af	; HAVE WE COLLECTED BEFORE?
	ld	de,0+ERRSO	; GET READY FOR OUT OF STRING SPACE ERROR
	jp	z,ERROR	; GO TELL USER HE LOST
	cp	a	; SET ZERO FLAG TO SAY WEVE GARBAGED
	push	af	; SAVE FLAG BACK ON STACK
	ld	bc,TRYGI2	; PLACE FOR GARBAG TO RETURN TO.
	push	bc	; SAVE ON STACK
GARBA2:	ld	hl,(MEMSIZ)	; START FROM TOP DOWN
FNDVAR:	ld	(FRETOP),hl	; LIKE SO
	ld	hl,0	; GET DOUBLE ZERO
	push	hl	; SAY DIDNT SEE VARS THIS PASS
	ld	hl,(STREND)	; FORCE DVARS TO IGNORE STRINGS
			; IN THE PROGRAM TEXT (LITERALS, DATA)
	push	hl	; FORCE FIND HIGH ADDRESS
	ld	hl,TEMPST	; GET START OF STRING TEMPS
TVAR:	ex	de,hl		; SAVE IN [D,E]
	ld	hl,(TEMPPT)	; SEE IF DONE
	ex	de,hl		; FLIP
	call	DCOMPR	; TEST
			; CANNOT RUN IN RAM SINCE IT STORES TO MESS UP BASIC
	ld	bc,TVAR	; FORCE JUMP TO TVAR
	jp	nz,DVAR2	; DO TEMP VAR GARBAGE COLLECT

	ld	hl,PRMPRV	; SETUP ITERATION FOR PARAMETER BLOCKS
	ld	(TEMP9),hl
	ld	hl,(ARYTAB)	; GET STOPPING POINT IN [H,L]
	ld	(ARYTA2),hl	; STORE IN STOP LOCATION
	ld	hl,(VARTAB)	; GET STARTING POINT IN [H,L]

SVAR:	ex	de,hl
	ld	hl,(ARYTA2)	; GET STOPPING LOCATION
	ex	de,hl
	call	DCOMPR	; SEE IF AT END OF SIMPS
	jp	z,ARYVAR
	ld	a,(hl)	; GET VALTYP
	inc	hl	; BUMP POINTER TWICE
	inc	hl
	inc	hl	; POINT AT THE VALUE
	push	af	; SAVE VALTYP
	call	IADAHL	; AND SKIP OVER EXTRA CHARACTERS AND COUNT
	pop	af
	cp	3	; SEE IF ITS A STRING
	jp	nz,SKPVAR	; IF NOT, JUST SKIP AROUND IT
	call	DVARS	; COLLECT IT
	xor	a	; AND DON'T SKIP ANYTHING MORE
SKPVAR:	ld	e,a
	ld	d,0	; [D,E]=AMOUNT TO SKIP
	add	hl,de
	jp	SVAR	; GET NEXT ONE
ARYVAR:	ld	hl,(TEMP9)	; GET LINK IN PARAMETER BLOCK CHAIN
	ld	a,(hl)	; GO BACK ONE LEVEL
	inc	hl
	ld	h,(hl)
	ld	l,a
	or	h	; WAS THAT THE END?
	ex	de,hl		; SETUP TO START ARRAYS
	ld	hl,(ARYTAB)
	jp	z,ARYVA4	; OTHERWISE GARBAGE COLLECT ARRAYS
	ex	de,hl
	ld	(TEMP9),hl	; SETUP NEXT LINK IN CHAIN FOR ITERATION
	inc	hl	; SKIP CHAIN POINTER
	inc	hl
	ld	e,(hl)	; PICK UP THE LENGTH
	inc	hl
	ld	d,(hl)
	inc	hl
	ex	de,hl		; SET [D,E]= ACTUAL END ADDRESS BY
	add	hl,de	; ADDING BASE TO LENGTH
	ld	(ARYTA2),hl	; SET UP STOP LOCATION
	ex	de,hl
	jp	SVAR

ARYVA2:	pop	bc	; GET RID OF STACK GARBAGE
ARYVA4:	ex	de,hl		; SAVE ARYVAR IN [D,E]
	ld	hl,(STREND)	; GET END OF ARRAYS
	ex	de,hl		; FLIP BACK
	call	DCOMPR	; SEE IF DONE WITH ARRAYS
	jp	z,GRBPAS	; YES, SEE IF DONE COLLECTING
	ld	a,(hl)	; GET THE VALUE TYPE INTO [A]
	inc	hl
	push	af	; SAVE THE VALTYP
	inc	hl	; SKIP THE NAME CHARACTERS
	inc	hl
	call	IADAHL	; SKIP THE EXTRA CHARACTERS
	ld	c,(hl)	; PICK UP THE LENGTH
	inc	hl
	ld	b,(hl)
	inc	hl
	pop	af	; RESTORE THE VALTYP
	push	hl	; SAVE POINTER TO DIMS
	add	hl,bc	; ADD TO CURRENT POINTER POSITION
	cp	3	; SEE IF ITS A STRING
	jp	nz,ARYVA2	; IF NOT JUST SKIP IT
	ld	(TEMP8),hl	; SAVE END OF ARRAY
	pop	hl	; GET BACK CURRENT POSITION
	ld	c,(hl)	; PICK UP NUMBER OF DIMS
	ld	b,0	; MAKE DOUBLE WITH HIGH ZERO
	add	hl,bc	; GO PAST DIMS
	add	hl,bc	; BY ADDING ON TWICE #DIMS (2 BYTE GUYS)
	inc	hl	; ONE MORE TO ACCOUNT FOR #DIMS.
ARYSTR:	ex	de,hl		; SAVE CURRENT POSIT IN [D,E]
	ld	hl,(TEMP8)	; GET END OF ARRAY
	ex	de,hl		; FIX [H,L] BACK TO CURRENT
	call	DCOMPR	; SEE IF AT END OF ARRAY
	jp	z,ARYVA4	; END OF ARRAY, TRY NEXT ARRAY
	ld	bc,ARYSTR	; ADDR OF WHERE TO RETURN TO
DVAR2:	push	bc	; GOES ON STACK
DVAR:	
DVARS:	xor	a
	or	(hl)	; SEE IF ITS THE NULL STRING
	inc	hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	inc	hl	; [D,E]=POINTER AT THE VALUE
	ret	z		; NULL STRING, RETURN
	ld	b,h	; MOVE [H,L] TO [B,C]
	ld	c,l
	ld	hl,(FRETOP)	; GET POINTER TO TOP OF STRING FREE SPACE
	call	DCOMPR	; IS THIS STRINGS POINTER .LT. FRETOP
	ld	h,b	; MOVE [B,C] BACK TO [H,L]
	ld	l,c
	ret	c		; IF NOT, NO NEED TO MESS WITH IT FURTHUR
	pop	hl	; GET RETURN ADDRESS OFF STACK
	ex	(sp),hl		; GET MAX SEEN SO FAR & SAVE RETURN ADDRESS
	call	DCOMPR	; LETS SEE
	ex	(sp),hl		; SAVE MAX SEEN & GET RETURN ADDRESS OFF STACK
	push	hl	; SAVE RETURN ADDRESS BACK
	ld	h,b	; MOVE [B,C] BACK TO [H,L]
	ld	l,c
	ret	nc		; IF NOT, LETS LOOK AT NEXT VAR
	pop	bc	; GET RETURN ADDR OFF STACK
	pop	af	; POP OFF MAX SEEN
	pop	af	; AND VARIABLE POINTER
	push	hl	; SAVE NEW VARIABLE POINTER
	push	de	; AND NEW MAX POINTER
	push	bc	; SAVE RETURN ADDRESS BACK
	ret		; AND RETURN
;
; HERE WHEN MADE ONE COMPLETE PASS THRU STRING VARS
;
GRBPAS:	pop	de	; POP OFF MAX POINTER
	pop	hl	; AND GET VARIABLE POINTER
	ld	a,l	; GET LOW IN
	or	h	; SEE IF ZERO POINTER
	ret	z		; IF END OF COLLECTION,
			; THEN MAYBE RETURN TO GETSPA
	dec	hl	; CURRENTLY JUST PAST THE DESCRIPTOR
	ld	b,(hl)	; [B]=HIGH BYTE OF DATA POINTER
	dec	hl
	ld	c,(hl)	; [B,C]=POINTER AT STRING DATA
	push	hl	; SAVE THIS LOCATION SO THE POINTER
			; CAN BE UPDATED AFTER THE STRING IS
			; MOVED
	dec	hl
	ld	l,(hl)	; [L]=STRING LENGTH
	ld	h,0	; [H,L] GET CHARACTER COUNT
	add	hl,bc	; [H,L]=POINTER BEYOND STRING
	ld	d,b
	ld	e,c	; [D,E]=ORIGINAL POINTER
	dec	hl	; DON'T MOVE ONE BEYOND STRING
	ld	b,h	; GET TOP OF STRING IN [B,C]
	ld	c,l
	ld	hl,(FRETOP)	; GET TOP OF FREE SPACE
	call	BLTUC	; MOVE STRING
	pop	hl	; GET BACK POINTER TO DESC.
	ld	(hl),c	; SAVE FIXED ADDR
	inc	hl	; MOVE POINTER
	ld	(hl),b	; HIGH PART
	ld	l,c
	ld	h,b	; [H,L]=NEW POINTER
	dec	hl	; FIX UP FRETOP
	jp	FNDVAR	; AND TRY TO FIND HIGH AGAIN

	PAGE
	SUBTTL	STRING CONCATENATION
;
; THE FOLLOWING ROUTINE CONCATENATES TWO STRINGS
; THE FACLO CONTAINS THE FIRST ONE AT THIS POINT,
; [H,L] POINTS BEYOND THE + SIGN AFTER IT
;
CAT:	push	bc	; PUT OLD PRECEDENCE BACK ON
	push	hl	; SAVE TEXT POINTER
	ld	hl,(FACLO)	; GET POINTER TO STRING DESC.
	ex	(sp),hl		; SAVE ON STACK & GET TEXT POINTER BACK
	call	EVAL	; EVALUATE REST OF FORMULA
	ex	(sp),hl		; SAVE TEXT POINTER, GET BACK DESC.
	call	CHKSTR
	ld	a,(hl)
	push	hl	; SAVE DESC. POINTER.
	ld	hl,(FACLO)	; GET POINTER TO 2ND DESC.
	push	hl	; SAVE IT
	add	a,(hl)	; ADD TWO LENGTHS TOGETHER
	ld	de,0+ERRLS	; SEE IF RESULT .LT. 256
	jp	c,ERROR	; ERROR "LONG STRING"
	call	STRINI	; GET INITIAL STRING
	pop	de	; GET 2ND DESC.
	call	FRETMP
	ex	(sp),hl		; SAVE POINTER TO IT
	call	FRETM2	; FREE UP 1ST TEMP
	push	hl	; SAVE DESC. POINTER (FIRST)
INCSTR	defl 2

INCSTR	defl 1
	ld	hl,(DSCTMP+INCSTR)	; GET POINTER TO FIRST
	ex	de,hl		; IN [D,E]
	call	MOVINS	; MOVE IN THE FIRST STRING
	call	MOVINS	; AND THE SECOND
	ld	hl,TSTOP	; CAT REENTERS FORMULA EVALUATION AT TSTOP
	ex	(sp),hl
	push	hl	; TEXT POINTER OFF FIRST
	jp	PUTNEW	; THEN RETURN ADDRESS OF TSTOP


MOVINS:	pop	hl	; GET RETURN ADDR
	ex	(sp),hl		; PUT BACK, BUT GET DESC.
	ld	a,(hl)	; [A]=STRING LENGTH
	inc	hl
	ld	c,(hl)	; [B,C]=POINTER AT STRING DATA
	inc	hl
	ld	b,(hl)
	ld	l,a	; [L]=STRING LENGTH
MOVSTR:	inc	l
MOVLP:	dec	l	; SET CC'S
	ret	z		; 0, NO BYTE TO MOVE
	ld	a,(bc)	; GET CHAR
	ld	(de),a	; SAVE IT
	inc	bc	; MOVE POINTERS
	inc	de
	jp	MOVLP	; KEEP DOING IT
	PAGE
	SUBTTL	FREE UP STRING TEMPORARY - FRESTR, FREFAC, FRETMP, FRETMS
;
; FRETMP IS PASSED A POINTER TO A STRING DESCRIPTOR IN [D,E]
; THIS VALUE IS RETURNED IN [H,L]. ALL THE OTHER REGISTERS ARE MODIFIED.
; A CHECK TO IS MADE TO SEE IF THE STRING DESCRIPTOR [D,E] POINTS
; TO IS THE LAST TEMPORARY DESCRIPTOR ALLOCATED BY PUTNEW.
; IF SO, THE TEMPORARY IS FREED UP BY THE UPDATING OF TEMPPT.
; IF A TEMPORARY IS FREED UP, A FURTHER CHECK IS MADE TO SEE IF THE
; STRING DATA THAT THAT STRING TEMPORARY POINTED TO IS THE
; THE LOWEST PART OF STRING SPACE IN USE.
; IF SO, FRETMP IS UPDATED TO REFLECT THE FACT THAT THAT SPACE IS NO
; LONGER IN USE.
;
	PUBLIC	FREFAC
FRESTR:	call	CHKSTR	; MAKE SURE ITS A STRING
FREFAC:	ld	hl,(FACLO)
	PUBLIC	FRETM2
FRETM2:	ex	de,hl		; FREE UP THE TEMP IN THE FACLO
FRETMP:	call	FRETMS	; FREE UP THE TEMPORARY
	ex	de,hl		; PUT THE STRING POINTER INTO [H,L]
	ret	nz
	push	de	; SAVE [D,E] TO RETURN IN [H,L]
	ld	d,b	; [D,E]=POINTER AT STRING
	ld	e,c
	dec	de	; SUBTRACT ONE
	ld	c,(hl)	; [C]=LENGTH OF THE STRING FREED UP
	ld	hl,(FRETOP)	; SEE IF ITS THE FIRST
			; ONE IN STRING SPACE
	call	DCOMPR
	jp	nz,NOTLST	; NO SO DON'T ADD
	ld	b,a	; MAKE [B]=0
	add	hl,bc	; ADD
	ld	(FRETOP),hl	; AND UPDATE FRETOP
NOTLST:	pop	hl	; GET POINTER AT CURRENT DESCRIPTOR
	ret
FRETMS:	ld	hl,(TEMPPT)	; GET TEMP POINTER
	dec	hl	; LOOK AT WHAT IS IN THE LAST TEMP
	ld	b,(hl)	; [B,C]=POINTER AT STRING
	dec	hl	; DECREMENT TEMPPT BY STRSIZ
	ld	c,(hl)
	dec	hl
	call	DCOMPR	; SEE IF [D,E] POINT AT THE LAST
	ret	nz		; RETURN NOW IF NOW FREEING DONE
	ld	(TEMPPT),hl	; UPDATE THE TEMP POINTER SINCE
			; ITS BEEN DECREMENTED BY 4
	ret
	PAGE
	SUBTTL	STRING FUNCTIONS - LEN, ASC, CHR$
;
; THE FUNCTION LEN($) RETURNS THE LENGTH OF THE
; STRING PASSED AS AN ARGUMENT
;
LEN:	ld	bc,SNGFLT	; CALL SNGFLT WHEN DONE
	push	bc	; LIKE SO
LEN1:	call	FRESTR	; FREE UP TEMP POINTED TO BY FACLO
	xor	a	; FORCE NUMERIC FLAG
	ld	d,a	; SET HIGH OF [D,E] TO ZERO FOR VAL
	ld	a,(hl)
	or	a	; SET CONDITION CODES ON LENGTH
	ret		; RETURN
;
; THE FOLLOWING IS THE ASC($) FUNCTION. IT RETURNS AN INTEGER
; WHICH IS THE DECIMAL ASCII EQUIVALENT
;
ASC:	
	ld	bc,SNGFLT	; WHERE TO GO WHEN DONE
	push	bc	; SAVE RETURN ADDR ON STACK
ASC2:	call	LEN1	; SET UP ORIGINAL STR
	jp	z,FCERR	; NULL STR, BAD ARG.
	inc	hl	; BUMP POINTER
	ld	e,(hl)	; [D,E]=POINTER AT STRING DATA
	inc	hl
	ld	d,(hl)
	ld	a,(de)	; [A]=FIRST CHARACTER
	ret
;
; CHR$(#) CREATES A STRING WHICH CONTAINS AS ITS ONLY
; CHARACTER THE ASCII EQUIVALENT OF THE INTEGER ARG (#)
; WHICH MUST BE .LE. 255.
;
CHR$:	call	STRIN1	; GET STRING IN DSCTMP
	call	CONINT	; GET INTEGER IN RANGE
INCSTR	defl 2

INCSTR	defl 1
	PUBLIC	SETSTR,FINBCK
SETSTR:	ld	hl,(DSCTMP+INCSTR)	; GET ADDR OF STR
	ld	(hl),e	; SAVE ASCII BYTE
FINBCK:	pop	bc	; RETURN TO HIGHER LEVEL &
			; SKIP THE CHKNUM CALL.
	jp	PUTNEW	; GO CALL PUTNEW

	PUBLIC	STRNG$
STRNG$:	call	CHRGTR	; GET NEXT CHAR FOLLOWING "STRING$"
	call	SYNCHR
	defb	'('	; MAKE SURE LEFT PAREN
	call	GETBYT	; EVALUATE FIRST ARG (LENGTH)
	push	de	; SAVE IT
	call	SYNCHR
	defb	2ch	; COMMA
	call	FRMEVL	; GET FORMULA ARG 2
	call	SYNCHR
	defb	')'	; EXPECT RIGHT PAREN
	ex	(sp),hl		; SAVE TEXT POINTER ON STACK, GET REP FACTOR
	push	hl	; SAVE BACK REP FACTOR
	call	GETYPR	; GET TYPE OF ARG
	jp	z,STRSTR	; WAS A STRING
	call	CONINT	; GET ASCII VALUE OF CHAR
	jp	CALSPA	; NOW CALL SPACE CODE
STRSTR:	call	ASC2	; GET VALUE OF CHAR IN [A]
CALSPA:	pop	de	; GET REP FACTOR IN [E]
	call	SPACE2	; INTO SPACE CODE, PUT DUMMY ENTRY
			; ON STACK POPPED OFF BY FINBCK
	PUBLIC	SPACE$
SPACE$:	call	CONINT	; GET NUMBER OF CHARS IN [E]
	ld	a,32	; GET SPACE CHAR
SPACE2:	push	af	; SAVE CHAR
	ld	a,e	; GET NUMBER OF CHARS IN [A]
	call	STRINI	; GET A STRING THAT LONG
	ld	b,a	; COUNT OF CHARS BACK IN [B]
	pop	af	; GET BACK CHAR TO PUT IN STRING
	inc	b	; TEST FOR NULL STRING
	dec	b
	jp	z,FINBCK	; YES, ALL DONE
	ld	hl,(DSCTMP+INCSTR)	; GET DESC. POINTER
SPLP$:	ld	(hl),a	; SAVE CHAR
	inc	hl	; BUMP PTR
			; DECR COUNT
	dec	b
	jp	nz,SPLP$	; KEEP STORING CHAR
	jp	FINBCK	; PUT TEMP DESC WHEN DONE
	PAGE
	SUBTTL	STRING FUNCTIONS - LEFT$, RIGHT$, MID$
;
; THE FOLLOWING IS THE LEFT$($,#) FUNCTION.
; IT TAKES THE LEFTMOST # CHARS OF THE STR.
; IF # IS .GT. THAN THE LEN OF THE STR, IT RETURNS THE WHOLE STR.
;
LEFT$:	call	PREAM	; TEST THE PARAMETERS
	xor	a	; LEFT NEVER CHANGES STRING POINTER
LEFT3:	ex	(sp),hl		; SAVE TEXT POINTER
	ld	c,a	; OFFSET NOW IN [C]
	defb	003eh	; SKIP THE NEXT BYTE WITH "MVI A,"
;
; THIS IS PRINT USINGS ENTRY POINT INTO LEFT$
;
	PUBLIC	LEFTUS
LEFTUS:	push	hl	; THIS IS A DUMMY PUSH TO OFFSET
			; THE EXTRA POP IN PUTNEW
LEFT2:	push	hl	; SAVE DESC. FOR FRETMP
	ld	a,(hl)	; GET STRING LENGTH
	cp	b	; ENTIRE STRING WANTED?
	jp	c,ALLSTR	; IF #CHARS ASKED FOR.GE.LENGTH,YES
	ld	a,b	; GET TRUNCATED LENGTH OF STRING
	defb	0011h	; SKIP OVER MVI USING "LXI D,"
ALLSTR:	ld	c,0	; MAKE OFFSET ZERO
	push	bc	; SAVE OFFSET ON STACK
	call	GETSPA	; GET SPACE FOR NEW STRING
	pop	bc	; GET BACK OFFSET
	pop	hl	; GET BACK DESC POINTER.
	push	hl	; BUT KEEP ON STACK
	inc	hl	; MOVE TO STRING POINTER FIELD
	ld	b,(hl)	; GET POINTER LOW
	inc	hl
	ld	h,(hl)	; POINTER HIGH
	ld	l,b	; GET LOW IN L
	ld	b,0	; GET READY TO ADD OFFSET TO POINTER
	add	hl,bc	; ADD IT
	ld	b,h	; GET OFFSET POINTER IN [B,C]
	ld	c,l
	call	STRAD2	; SAVE INFO IN DSCTMP
	ld	l,a	; GET# OF CHARS TO MOVE IN L
	call	MOVSTR	; MOVE THEM IN
	pop	de	; GET BACK DESC. POINTER
	call	FRETMP	; FREE IT UP.
	jp	PUTNEW	; PUT TEMP IN TEMP LIST

RIGHT$:	call	PREAM	; CHECK ARG
	pop	de	; GET DESC. POINTER
	push	de	; SAVE BACK FOR LEFT
	ld	a,(de)	; GET PRESENT LEN OF STR
	sub	b	; SUBTRACT 2ND PARM
	jp	LEFT3	; CONTINUE WITH LEFT CODE
;
; MID ($,#) RETURNS STR WITH CHARS FROM # POSITION
; ONWARD. IF # IS GT LEN($) THEN RETURN NULL STRING.
; MID ($,#,#) RETURNS STR WITH CHARS FROM # POSITION
; FOR #2 CHARS. IF #2 GOES PAST END OF STRING, RETURN
; AS MUCH AS POSSIBLE.
;
MID$:	ex	de,hl		; PUT THE TEXT POINTER IN [H,L]
	ld	a,(hl)	; GET THE FIRST CHARACTER
	call	PREAM2	; GET OFFSET OFF STACK AND MAKE
	inc	b
	dec	b	; SEE IF EQUAL TO ZERO
	jp	z,FCERR	; IT MUST NOT BE 0
			; SURE DOES NOT = 0.
	push	bc	; PUT OFFSET ON TO THE STACK
	call	MIDRST	; DUPLICATE OF CODE CONDITIONED OUT
			; BELOW
	pop	af	; GET OFFSET BACK IN A
	ex	(sp),hl		; SAVE TEXT POINTER, GET DESC.
	ld	bc,LEFT2	; WHERE TO RETURN TO.
	push	bc	; GOES ON STACK
	dec	a	; SUB ONE FROM OFFSET
	cp	(hl)	; POINTER PAST END OF STR?
	ld	b,0	; ASSUME NULL LENGTH STR
	ret	nc		; YES, JUST USE NULL STR
	ld	c,a	; SAVE OFFSET OF CHARACTER POINTER
	ld	a,(hl)	; GET PRESENT LEN OF STR
	sub	c	; SUBTRACT INDEX (2ND ARG)
	cp	e	; IS IT TRUNCATION
	ld	b,a	; GET CALCED LENGTH IN B
	ret	c		; IF NOT USE PARTIAL STR
	ld	b,e	; USE TRUNCATED LENGTH
	ret		; RETURN TO LEFT2
;
; THE VAL FUNCTION TAKES A STRING AND TURN IT INTO
; A NUMBER BY INTERPRETING THE ASCII DIGITS. ETC..
; EXCEPT FOR THE PROBLEM THAT A TERMINATOR MUST BE SUPPLIED
; BY REPLACING THE CHARACTER BEYOND THE STRING, VAL
; IS MERELY A CALL TO FLOATING INPUT (FIN).
;
VAL:	call	LEN1	; DO SETUP, SET RESULT=REAL
	jp	z,SNGFLT	; MAKE SURE TYPE SET UP OK IN EXTENDED
	ld	e,a	; GET LENGTH OF STR
	inc	hl	; TO HANDLE THE FACT THE IF
	ld	a,(hl)
	inc	hl
	ld	h,(hl)	; TWO STRINGS "1" AND "2"
	ld	l,a	; ARE STORED NEXT TO EACH OTHER
	push	hl	; AND FIN IS CALLED POINTING TO
	add	hl,de	; THE FIRST TWELVE WILL BE RETURNED
	ld	b,(hl)	; THE IDEA IS TO STORE 0 IN THE
	ld	(hl),d	; STRING BEYOND THE ONE VAL
	ex	(sp),hl		; IS BEING CALLED ON
	push	bc	; THE FIRST CHARACTER OF THE NEXT STRING
	dec	hl	; ***CALL CHRGET TO MAKE SURE
	call	CHRGTR	; VAL(" -3")=-3
	call	FINDBL	; IN EXTENDED, GET ALL THE PRECISION WE CAN
	pop	bc	; GET THE MODIFIED CHARACTER OF THE NEXT
			; STRING INTO [B]
	pop	hl	; GET THE POINTER TO THE MODIFIED CHARACTER
	ld	(hl),b	; RESTORE THE CHARACTER
			; IF STRING IS HIGHEST IN STRING SPACE
			; WE ARE MODIFYING [MEMSIZ] AND
			; THIS IS WHY [MEMSIZ] CAN'T BE USED TO STORE
			; STRING DATA BECAUSE WHAT IF THE
			; USER TOOK VAL OFF THAT HIGH STRING
	ret
;USED BY RIGHT$ AND LEFT$ FOR PARAMETER CHECKING AND SETUP
PREAM:	ex	de,hl		; PUT THE TEXT POINTER IN [H,L]
	call	SYNCHR
	defb	')'	; PARAM LIST SHOULD END
;USED BY MID$ FOR PARAMETER CHECKING AND SETUP
PREAM2:	pop	bc	; GET RETURN ADDR OFF STACK
	pop	de	; GET LENGTH OF ARG OFF STACK
	push	bc	; SAVE RETURN ADDR BACK ON
	ld	b,e	; SAVE INIT LENGTH
	ret

	PAGE
	SUBTTL	STRING FUNCTIONS - INSTR

; THIS IS THE INSTR FUCNTION. IT TAKES ONE OF TWO
; FORMS: INSTR(I%,S1$,S2$) OR INSTR(S1$,S2$)
; IN THE FIRST FORM THE STRING S1$ IS SEARCHED FOR THE
; CHARACTER S2$ STARTING AT CHARACTER POSITION I%.
; THE SECOND FORM IS IDENTICAL, EXCEPT THAT THE SEARCH
; STARTS AT POSITION 1. INSTR RETURNS THE CHARACTER
; POSITION OF THE FIRST OCCURANCE OF S2$ IN S1$.
; IF S1$ IS NULL, 0 IS RETURNED. IF S2$ IS NULL, THEN
; I% IS RETURNED, UNLESS I% .GT. LEN(S1$) IN WHICH
; CASE 0 IS RETURNED.

	PUBLIC	INSTR
INSTR:	call	CHRGTR	; EAT FIRST CHAR
	call	FRMPRN	; EVALUATE FIRST ARG
	call	GETYPR	; SET ZERO IF ARG A STRING.
	ld	a,1	; IF SO, ASSUME, SEARCH STARTS AT FIRST CHAR
	push	af	; SAVE OFFSET IN CASE STRING
	jp	z,WUZSTR	; WAS A STRING
	pop	af	; GET RID OF SAVED OFFSET
	call	CONINT	; FORCE ARG1 (I%) TO BE INTEGER
	or	a	; DONT ALLOW ZERO OFFSET
	jp	z,FCERR	; KILL HIM.
	push	af	; SAVE FOR LATER
	call	SYNCHR
	defb	44	; EAT THE COMMA
	call	FRMEVL	; EAT FIRST STRING ARG
	call	CHKSTR	; BLOW UP IF NOT STRING
WUZSTR:	call	SYNCHR
	defb	44	; EAT COMMA AFTER ARG
	push	hl	; SAVE THE TEXT POINTER
	ld	hl,(FACLO)	; GET DESCRIPTOR POINTER
	ex	(sp),hl		; PUT ON STACK & GET BACK TEXT PNT.
	call	FRMEVL	; GET LAST ARG
	call	SYNCHR
	defb	')'	; EAT RIGHT PAREN
	push	hl	; SAVE TEXT POINTER
	call	FRESTR	; FREE UP TEMP & CHECK STRING
	ex	de,hl		; SAVE 2ND DESC. POINTER IN [D,E]
	pop	bc	; GET TEXT POINTER IN B
	pop	hl	; DESC. POINTER FOR S1$
	pop	af	; OFFSET
	push	bc	; PUT TEXT POINTER ON BOTTOM
	ld	bc,POPHRT	; PUT ADDRESS OF POP H, RET ON
	push	bc	; PUSH IT
	ld	bc,SNGFLT	; NOW ADDRESS OF [A] RETURNER
	push	bc	; ONTO STACK
	push	af	; SAVE OFFSET BACK
	push	de	; SAVE DESC. OF S2
	call	FRETM2	; FREE UP S1 DESC.
	pop	de	; RESTORE DESC. S2
	pop	af	; GET BACK OFFSET
	ld	b,a	; SAVE UNMODIFIED OFFSET
	dec	a	; MAKE OFFSET OK
	ld	c,a	; SAVE IN C
	cp	(hl)	; IS IT BEYOND LENGTH OF S1?
	ld	a,0	; IF SO, RETURN ZERO. (ERROR)
	ret	nc
	ld	a,(de)	; GET LENGTH OF S2$
	or	a	; NULL??
	ld	a,b	; GET OFFSET BACK
	ret	z		; ALL IF S2 NULL, RETURN OFFSET
	ld	a,(hl)	; GET LENGTH OF S1$
	inc	hl	; BUMP POINTER
	ld	b,(hl)	; GET 1ST BYTE OF ADDRESS
	inc	hl	; BUMP POINTER
	ld	h,(hl)	; GET 2ND BYTE
	ld	l,b	; GET 1ST BYTE SET UP
	ld	b,0	; GET READY FOR DAD
	add	hl,bc	; NOW INDEXING INTO STRING
	sub	c	; MAKE LENGTH OF STRING S1$ RIGHT
	ld	b,a	; SAVE LENGTH OF 1ST STRING IN [B]
	push	bc	; SAVE COUNTER, OFFSET
	push	de	; PUT 2ND DESC (S2$) ON STACK
	ex	(sp),hl		; GET 2ND DESC. POINTER
	ld	c,(hl)	; SET UP LENGTH
	inc	hl	; BUMP POINTER
	ld	e,(hl)	; GET FIRST BYTE OF ADDRESS
	inc	hl	; BUMP POINTER AGAIN
	ld	d,(hl)	; GET 2ND BYTE
	pop	hl	; RESTORE POINTER FOR 1ST STRING

CHK1:	push	hl	; SAVE POSITION IN SEARCH STRING
	push	de	; SAVE START OF SUBSTRING
	push	bc	; SAVE WHERE WE STARTED SEARCH
CHK:	ld	a,(de)	; GET CHAR FROM SUBSTRING
	cp	(hl)	;  = CHAR POINTER TO BY [H,L]
	jp	nz,OHWELL	; NO
	inc	de	; BUMP COMPARE POINTER
	dec	c	; END OF SEARCH STRING?
	jp	z,GOTSTR	; WE FOUND IT!
	inc	hl	; BUMP POINTER INTO STRING BEING SEARCHED
			; DECREMENT LENGTH OF SEARCH STRING
	dec	b
	jp	nz,CHK	; END OF STRING, YOU LOSE
RETZER:	pop	de	; GET RID OF POINTERS
	pop	de	; GET RID OF GARB
	pop	bc	; LIKE SO
RETZR1:	pop	de
	xor	a	; GO TO SNGFLT.
	ret		; RETURN

GOTSTR:	pop	hl
	pop	de	; GET RID OF GARB
	pop	de	; GET RID OF EXCESS STACK
	pop	bc	; GET COUNTER, OFFSET
	ld	a,b	; GET ORIGINAL SOURCE COUNTER
	sub	h	; SUBTRACT FINAL COUNTER
	add	a,c	; ADD ORIGINAL OFFSET (N1%)
	inc	a	; MAKE OFFSET OF ZERO = POSIT 1
	ret		; DONE


OHWELL:	pop	bc
	pop	de	; POINT TO START OF SUBSTRING
	pop	hl	; GET BACK WHERE WE STARTED TO COMPARE
	inc	hl	; AND POINT TO NEXT CHAR
			; DECR. # CHAR LEFT IN SOURCE STRING
	dec	b
	jp	nz,CHK1	; TRY SEARCHING SOME MORE
	jp	RETZR1	; END OF STRING, RETURN 0

	PAGE
	SUBTTL	STRING FUNCTIONS - LEFT HAND SIDE MID$
LHSMID:	call	SYNCHR
	defb	'('	; MUST HAVE (
	call	PTRGET	; GET A STRING VAR
	call	CHKSTR	; MAKE SURE IT WAS A STRING
	push	hl	; SAVE TEXT POINTER
	push	de	; SAVE DESC. POINTER
	ex	de,hl		; PUT DESC. POINTER IN [H,L]
	inc	hl	; MOVE TO ADDRESS FIELD
	ld	e,(hl)	; GET ADDRESS OF LHS IN [D,E]
	inc	hl	; BUMP DESC. POINTER
	ld	d,(hl)	; PICK UP HIGH BYTE OF ADDRESS
	ld	hl,(STREND)	; SEE IF LHS STRING IS IN STRING SPACE
	call	DCOMPR	; BY COMPARING IT WITH STKTOP
	jp	c,NCPMID	; IF ALREADY IN STRING SPACE
			; DONT COPY.

			; 9/23/79 Allow MID$ on field strings
	EXTRN	TXTTAB
	ld	hl,(TXTTAB)
	call	DCOMPR	; Is this a fielded string?
	jp	nc,NCPMID	; Yes, Don't copy!!
	pop	hl	; GET BACK DESC. POINTER
	push	hl	; SAVE BACK ON STACK
	call	STRCPY	; COPY THE STRING LITERAL INTO STRING SPACE
	pop	hl	; GET BACK DESC. POINTER
	push	hl	; BACK ON STACK AGAIN
	call	VMOVE	; MOVE NEW DESC. INTO OLD SLOT.
NCPMID:	pop	hl	; GET DESC. POINTER
	ex	(sp),hl		; GET TEXT POINTER TO [H,L] DESC. TO STACK
	call	SYNCHR
	defb	2ch	; MUST HAVE COMMA
	call	GETBYT	; GET ARG#2 (OFFSET INTO STRING)
	or	a	; MAKE SURE NOT ZERO
	jp	z,FCERR	; BLOW HIM UP IF ZERO
	push	af	; SAVE ARG#2 ON STACK
	ld	a,(hl)	; RESTORE CURRENT CHAR
	call	MIDRST	; USE MID$ CODE TO EVALUATE POSIBLE THIRD ARG.
	push	de	; SAVE THIRD ARG ([E]) ON STACK
			; MUST HAVE = SIGN
	call	FRMEQL	; EVALUATE RHS OF THING.
	push	hl	; SAVE TEXT POINTER.
	call	FRESTR	; FREE UP TEMP RHS IF ANY.
	ex	de,hl		; PUT RHS DESC. POINTER IN [D,E]
	pop	hl	; TEXT POINTER TO [H,L]
	pop	bc	; ARG #3 TO C.
	pop	af	; ARG #2 TO A.
	ld	b,a	; AND [B]
	ex	(sp),hl		; GET LHS DESC. POINTER TO [H,L]
			; TEXT POINTER TO STACK
	push	hl	; SAVE TEXT POINTER
	ld	hl,POPHRT	; GET ADDR TO RETURN TO
	ex	(sp),hl		; SAVE ON STACK & GET BACK TXT PTR.
	ld	a,c	; GET ARG #3
	or	a	; SET CC'S
	ret	z		; IF ZERO, DO NOTHING
	ld	a,(hl)	; GET LENGTH OF LHS
	sub	b	; SEE HOW MANY CHARS IN EMAINDER OF STRING
	jp	c,FCERR	; CANT ASSIGN PAST LEN(LHS)!
	inc	a	; MAKE PROPER COUNT
	cp	c	; SEE IF # OF CHARS IS .GT. THIRD ARG
	jp	c,BIGLEN	; IF SO, DONT TRUNCATE
	ld	a,c	; TRUNCATE BY USING 3RD ARG.
BIGLEN:	ld	c,b	; GET OFFSET OF STRING IN [C]
	dec	c	; MAKE PROPER OFFSET
	ld	b,0	; SET UP [B,C] FOR LATER DAD B.
	push	de	; SAVE [D,E]
	inc	hl	; POINTER TO ADDRESS FIELD.
	ld	e,(hl)	; GET LOW BYTE IN [E]
	inc	hl	; BUMP POINTER
	ld	h,(hl)	; GET HIGH BYTE IN [H]
	ld	l,e	; NOW COPY LOW BYTE BACK TO [L]
	add	hl,bc	; ADD OFFSET
	ld	b,a	; SET COUNT OF LHS IN [B]
	pop	de	; RESTORE [D,E]
	ex	de,hl		; MOVE RHS. DESC. POINTER TO [H,L]
	ld	c,(hl)	; GET LEN(RHS) IN [C]
	inc	hl	; MOVE POINTER
	ld	a,(hl)	; GET LOW BYTE OF ADDRESS IN [A]
	inc	hl	; BUMP POINTER.
	ld	h,(hl)	; GET HIGH BYTE OF ADDRESS IN [H]
	ld	l,a	; COPY LOW BYTE TO [L]
	ex	de,hl		; ADDRESS OF RHS NOW IN [D,E]
	ld	a,c	; IS RHS NULL?
	or	a	; TEST
	ret	z		; THEN ALL DONE.
; NOW ALL SET UP FOR ASSIGNMENT.
; [H,L] = LHS POINTER
; [D,E] = RHS POINTER
; C = LEN(RHS)
; B = LEN(LHS)

MID$LP:	ld	a,(de)	; GET BYTE FROM RHS.
	ld	(hl),a	; STORE IN LHS
	inc	de	; BUMP RHS POINTER
	inc	hl	; BUMP LHS POINTER.
	dec	c	; BUMP DOWN COUNT OF RHS.
	ret	z		; IF ZERO, ALL DONE.
			; IF LHS ENDED, ALSO DONE.
	dec	b
	jp	nz,MID$LP	; IF NOT DONE, MORE COPYING.
	ret		; BACK TO NEWSTT

MIDRST:	ld	e,255	; IF TWO ARG GUY, TRUNCATE.
	cp	')'
	jp	z,MID2	; [E] SAYS USE ALL CHARS
			; IF ONE ARGUMENT THIS IS CORRECT
	call	SYNCHR
	defb	44	; COMMA? MUST DELINEATE 3RD ARG.
	call	GETBYT	; GET ARGUMENT IN [E]
MID2:	call	SYNCHR
	defb	')'	; MUST BE FOLLOWED BY )
	ret		; ALL DONE.

	SUBTTL	FRE FUNCTION AND INTEGER TO FLOATING ROUTINES
FRE:	
	call	GETYPR
	jp	nz,CLCDIF
	call	FREFAC	; FREE UP ARGUMENT AND SETUP
			; TO GIVE FREE STRING SPACE
	call	GARBA2	; DO GARBAGE COLLECTION
CLCDIF:	ld	hl,(STREND)
	ex	de,hl
	ld	hl,(FRETOP)	; TOP OF FREE AREA
	jp	GIVDBL	; RETURN [H,L]-[D,E]
	end

