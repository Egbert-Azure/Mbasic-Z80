	.symlen 6
	SUBTTL	Common file for BASIC interpreter
	.SALL

CONTO	defl 15	; CHARACTER TO SUPRESS OUTPUT (USUALLY CONTROL-O)
DBLTRN	defl 0	; FOR DOUBLE PRECISION TRANSCENDENTALS
	IF2

	.printx	/EXTENDED/


	.printx	/LPT/

	.printx	/CPM DISK/


	.printx	/Z80/

	.printx	/FAST/

	.printx	/5.0 FEATURES/

	.printx	/ANSI COMPATIBLE/
	ENDIF

CLMWID	defl 14	; MAKE COMMA COLUMNS FOURTEEN CHARACTERS
DATPSC	defl 128	; NUMBER OF DATA BYTES IN DISK SECTOR
LINLN	defl 80	; TERMINAL LINE LENGTH
LPTLEN	defl 132
BUFLEN	defl 255	; LONG LINES
NAMLEN	defl 40	; MAXIMUM LENGTH NAME -- 3 TO 127

NUMLEV	defl 0*20+19+2*5	; NUMBER OF STACK LEVELS RESERVED
			; BY AN EXPLICIT CALL TO GETSTK

STRSIZ	defl 4

STRSIZ	defl 3
NUMTMP	defl 3	; NUMBER OF STRING TEMPORARIES

NUMTMP	defl 10

MD.RND	defl 3	; THE MODE NUMBER FOR RANDOM FILES
MD.SQI	defl 1	; THE MODE NUMBER FOR SEQUENTIAL INPUT FILES
			; NEVER WRITTEN INTO A FILE
MD.SQO	defl 2	; THE MODE FOR SEQUENTIAL OUTPUT FILES
			; AND PROGRAM FILES
CPMWRM	defl 0	; CP/M WARM BOOT ADDR
CPMENT	defl CPMWRM+5	; CP/M BDOS CALL ADDR
	CSEG
TRUROM	defl 0
	PAGE
	TITLE	BIMISC BASIC Interpreter miscellaneous routines/WHG/PGA etc.
	EXTRN	ARYTAB,BRKTXT,CRDO,CRDONZ,CURLIN,DATPTR,ERROR,FADDS
	EXTRN	FCERR,FCOMP,FNDFOR,FNDLIN,FRETOP,FRMEVL,INCHRI,INLIN,LINGET
	EXTRN	MEMSIZ,MOVFM,MOVMF,MOVRM,NEWSTT,OLDLIN,OLDTXT,OVERR,PTRGET
	EXTRN	SNERR,STREND,SUBFLG,OUTDO,SAVTXT,CHRCON

	EXTRN	TOPMEM
	EXTRN	TEMP,TEMPPT,TEMPST,TMERR,TXTTAB,USERR,VALTYP,VARTAB
	EXTRN	ERRCN,ERRFIN,ERROM,GETBYT,STPRDY,NFERR,INTID2,NXTCON
	PUBLIC	SYNCHR,DCOMPR
	EXTRN	CHRGTR
	EXTRN	GETYPR
	EXTRN	VMOVE,PRMLEN,PRMLN2,DEFTBL,FRQINT,FUNACT,IADD,ICOMP,NOFUNS,PRMSTK
	EXTRN	OPTFLG,OPTVAL
	PUBLIC	STOPRG
	PUBLIC	TON,TOFF
	EXTRN	ONEFLG,ONELIN,TRCFLG,SAVSTK
	EXTRN	NXTFLG
	PUBLIC	CLEARC,SCRATH,STOP,ISLET,ISLET2,STKINI,GETSTK,SCRTCH
	PUBLIC	STPEND,BLTU,CONT,BLTUC,ENDS,GTMPRT,RUNC,STPEND,ENDCON,RESTOR
	PUBLIC	STOP,RESFIN,STKERR,REASON,OMERR
	PUBLIC	NEXT
;
; THIS IS THE BLOCK TRANSFER ROUTINE
; IT MAKES SPACE BY SHOVING EVERYTHING FORWARD
;
; [H,L] = DESTINATION OF HIGH ADDRESS
; [D,E] = LOW ADDRESS TO BE TRANSFERRED
; [B,C] = HIGH ADDRESS TO BE TRANSFERRED
;
; A CHECK IS MADE TO MAKE SURE A REASONABLE AMOUNT
; OF SPACE REMAINS BETWEEN THE TOP OF THE STACK AND
; THE HIGHEST LOCATION TRANSFERRED INTO
;
; ON EXIT [H,L]=[D,E]=LOW [B,C]=LOCATION LOW WAS MOVED INTO
;
BLTU:	call	REASON	; CHECK DESTINATION TO MAKE
			; SURE THE STACK WON'T BE OVERRUN
BLTUC:	push	bc	; EXCHANGE [B,C] AND [H,L]
	ex	(sp),hl
	pop	bc
BLTLOP:	call	DCOMPR	; SEE IF WE ARE DONE
	ld	a,(hl)	; GET THE WORD TO TRANSFER
	ld	(bc),a	; TRANSFER IT
	ret	z
	dec	bc
	dec	hl	; BACKUP FOR NEXT GUY
	jp	BLTLOP
;
; THIS ROUTINE IS USED TO MAKE SURE A CERTAIN NUMBER
; OF LOCATIONS REMAIN AVAILABLE FOR THE
; STACK. THE CALL IS :
;	MVI	C,NUMBER OF 2 BYTE ENTRIES NECESSARY
;	CALL	GETSTK
;
; THIS ROUTINE MUST BE CALLED BY ANY ROUTINE WHICH PUTS
; AN ARBITRARY AMOUNT OF STUFF ON THE STACK
; (I.E. ANY RECURSIVE ROUTINE LIKE FRMEVL)
; IT IS ALSO CALLED BY ROUTINES SUCH AS "GOSUB" AND "FOR"
; WHICH MAKE PERMANENT ENTRIES ON THE STACK
; ROUTINES WHICH MERELY USE AND FREE UP THE GUARANTEED
; NUMLEV STACK LOCATIONS NEED NOT CALL THIS
;
GETSTK:	push	hl	; SAVE [H,L]
	ld	hl,(MEMSIZ)
	ld	b,0
	add	hl,bc
	add	hl,bc	; SEE IF WE CAN HAVE THIS MANY
;
; [H,L]= SOME ADDRESS
; [H,L] IS EXAMINED TO MAKE SURE AT LEAST NUMLEV
; LOCATIONS REMAIN BETWEEN IT AND THE TOP OF THE STACK
;
CONS1	defl 256-(2*NUMLEV)
	ld	a,CONS1	; SET [H,L]=-[H,L]-2*NUMLEV
	sub	l
	ld	l,a
	ld	a,255
	sbc	a,h
	jp	c,OMERR	; IN CASE [H,L] WAS TOO BIG(MBM 3/18**)
	ld	h,a	; NOW SEE IF [SP] IS LARGER
	add	hl,sp	; IF SO, CARRY WILL BE SET
	pop	hl	; GET BACK ORIGINAL [H,L]
	ret	c		; WAS OK?
OMERR:	

			; FOR SPACE REASONS LEAVE THIS CODE OUT

			; ONLY IMPORTANT IN VERSIONS WHERE
			; STACK CONTEXT SURVIVES OTHER ERRORS
	ld	hl,(TOPMEM)
	dec	hl	; UP SOME MEMORY SPACE
	dec	hl	; MAKE SURE THE FNDFOR STOPPER IS SAVED
	ld	(SAVSTK),hl	; PLACE STACK IS RESTORED FROM
OMERRR:	ld	de,0+ERROM	; "OUT OF MEMORY"
	jp	ERROR
	EXTRN	GARBA2
REASON:	call	REALLY	; ENOUGH SPACE BETWEEN STRING & STACK
	ret	nc		; YES
	push	bc	; SAVE ALL REGS
	push	de
	push	hl
	call	GARBA2	; DO A GARBAGE COLLECTION
	pop	hl	; RESTORE ALL REGS
	pop	de
	pop	bc
	call	REALLY	; ENOUGH SPACE THIS TIME?
	ret	nc		; YES
	jp	OMERRR	; NO, GIVE "OUT OF MEMORY BUT DONT TOUCH STACK
REALLY:	push	de	; SAVE [D,E]
	ex	de,hl		; SAVE [H,L] IN [D,E]
	ld	hl,(FRETOP)	; GET WHERE STRINGS ARE
	call	DCOMPR	; IS TOP OF VARS LESS THAN STRINGS?
	ex	de,hl		; BACK TO [D,E]
	pop	de	; RESTORE [D,E]
	ret		; DONE
	PAGE
	SUBTTL	NODSKS, SCRATCH (NEW), RUNC, CLEARC, STKINI, QINLIN
	PUBLIC	NODSKS
	EXTRN	FILPTR,MAXFIL
; THE CODE BELOW SETS THE FILE MODE TO 0 (CLOSED) FOR ALL FCB'S
NODSKS:	ld	a,(MAXFIL)	; GET LARGEST FILE #
	ld	b,a	; INTO B FOR COUNTER
	ld	hl,FILPTR	; POINT TO TABLE OF FILE DATA BLOCKS
	xor	a	; MAKE A ZERO TO MARK FILES AS CLOSED
	inc	b
LOPNTO:	ld	e,(hl)	; GET POINTER TO FILE DATA BLOCK IN [D,E]
	inc	hl
	ld	d,(hl)
	inc	hl
	ld	(de),a	; MARK FILE AS CLOSED (MODE ZERO)
	dec	b
	jp	nz,LOPNTO	; LOOP UNTIL DONE
	EXTRN	CLSALL
	call	CLSALL
	xor	a
			; DONT WIPE OUT INIT MESSAGE ON SCREEN(NEW DOES CLEAR SCREEN)
;
; THE "NEW" COMMAND CLEARS THE PROGRAM TEXT AS WELL
; AS VARIABLE SPACE
;
SCRATH:	ret	nz		; MAKE SURE THERE IS A TERMINATOR
SCRTCH:	
	ld	hl,(TXTTAB)	; GET POINTER TO START OF TEXT
	call	TOFF	; TURN OFF TRACE. SET [A]=0.
	EXTRN	PROFLG
	ld	(PROFLG),a	; NO LONGER A PROTECTED FILE
	EXTRN	AUTFLG
	ld	(AUTFLG),a	; CLEAR AUTO MODE
	EXTRN	PTRFLG
	ld	(PTRFLG),a	; SAY NO POINTERS EXIST
	ld	(hl),a	; SAVE AT END OFF TEXT
	inc	hl	; BUMP POINTER
	ld	(hl),a	; SAVE ZERO
	inc	hl	; BUMP POINTER
	ld	(VARTAB),hl	; NEW START OF VARIABLES
RUNC:	
	ld	hl,(TXTTAB)	; POINT AT THE START OF TEXT
	dec	hl
;
; CLEARC IS A SUBROUTINE WHICH INITIALIZES THE VARIABLE AND
; ARRAY SPACE BY RESETING ARYTAB [THE END OF SIMPLE VARIABLE SPACE]
; AND STREND [THE END OF ARRAY STORAGE]. IT FALLS INTO STKINI
; WHICH RESETS THE STACK. [H,L] IS PRESERVED.
;
CLEARC:	ld	(TEMP),hl	; SAVE [H,L] IN TEMP
	EXTRN	MRGFLG
	ld	a,(MRGFLG)	; DOING A CHAIN MERGE?
	or	a	; TEST
	jp	nz,LEVDTB	; LEAVE DEFAULT TABLE ALONE
	xor	a
	ld	(OPTFLG),a	; INDICATE NO "OPTION" HAS BEEN SEEN
	ld	(OPTVAL),a	; DEFAULT TO "OPTION BASE 0"
	ld	b,26	; INITIALIZE THE DEFAULT VALTYPE TABLE
	ld	hl,DEFTBL	; POINT AT THE FIRST ENTRY
LOPDFT:	ld	(hl),4	; LOOP 26 TIMES STORING A DEFAULT VALTYP
	inc	hl	; FOR SINGLE PRECISION
			; COUNT OFF THE LETTERS
	dec	b
	jp	nz,LOPDFT	; LOOP BACK, AND SETUP THE REST OF THE TABLE
LEVDTB:	
	EXTRN	RNDCOP,RNDX,MOVE
	EXTRN	RNDCNT
	ld	de,RNDCOP	; RESET THE RANDOM NUMBER GENERATOR
	ld	hl,RNDX	; SEED IN RNDX
	call	MOVE
	ld	hl,RNDCNT-1	; AND ZERO COUNT REGISTERS
	xor	a
	ld	(hl),a
	inc	hl
	ld	(hl),a
	inc	hl
	ld	(hl),a
	xor	a
	ld	(ONEFLG),a	; RESET ON ERROR FLAG FOR RUNS
	ld	l,a	; RESET ERROR LINE NUMBER
	ld	h,a	; BY SETTING ONELIN=0.
	ld	(ONELIN),hl
	ld	(OLDTXT),hl	; MAKE CONTINUING IMPOSSIBLE
	ld	hl,(MEMSIZ)
	EXTRN	CHNFLG
	ld	a,(CHNFLG)	; ARE WE CHAINING?
	or	a	; TEST
	jp	nz,GODFRE	; FRETOP IS GOOD, LEAVE IT ALONE
	ld	(FRETOP),hl	; FREE UP STRING SPACE
GODFRE:	xor	a	; MAKE SURE [A] IS ZERO, CC'S SET
	call	RESTOR	; RESTORE DATA
	ld	hl,(VARTAB)	; GET START OF VARIABLE SPACE
	ld	(ARYTAB),hl	; SAVE IN START OF ARRAY SPACE
	ld	(STREND),hl	; AND END OF VARIABLE STORAGE
	EXTRN	CLSALL
	ld	a,(MRGFLG)	; DOING CHAIN MERGE?
	or	a
	call	z,CLSALL	; IF SO, DONT CLOSE FILES...
;
; STKINI RESETS THE STACK POINTER ELIMINATING
; GOSUB & FOR CONTEXT.  STRING TEMPORARIES ARE FREED
; UP, SUBFLG IS RESET, CONTINUING IS DISALLOWED,
; AND A DUMMY ENTRY IS PUT ON THE STACK. THIS IS SO
; FNDFOR WILL ALWAYS FIND A NON-"FOR" ENTRY AT THE BOTTOM
; OF THE STACK. [A]=0 AND [D,E] IS PRESERVED.
;
STKINI:	pop	bc	; GET RETURN ADDRESS HERE
	ld	hl,(TOPMEM)
	dec	hl	; TAKE INTO ACCOUNT FNDFOR STOPPER
	dec	hl
	ld	(SAVSTK),hl	; MAKE SURE SAVSTK OK JUST IN CASE.
	inc	hl	; INCREMENT BACK FOR SPHL
	inc	hl
STKERR:	ld	sp,hl		; INITIALIZE STACK
	ld	hl,TEMPST
	ld	(TEMPPT),hl	; INITIALIZE STRING TEMPORARIES
	EXTRN	CLROVC
	call	CLROVC	; BACK TO NORMAL OVERFLOW PRINT MODE
	EXTRN	FINLPT
	call	FINLPT
	EXTRN	FINPRT
	call	FINPRT	; CLEAR PTRFIL, OTHER I/O FLAGS
	xor	a	; ZERO OUT A
	ld	h,a	; ZERO OUT H
	ld	l,a	; ZERO OUT L
	ld	(PRMLEN),hl	; FLAG NO ACTIVE PARAMETERS
	ld	(NOFUNS),a	; INDICATE NO USER FUNCTIONS ACTIVE
	ld	(PRMLN2),hl	; NO PARAMETERS BEING BUILT
	ld	(FUNACT),hl	; SET NUMBER OF FUNCTIONS ACTIVE TO 0
	ld	(PRMSTK),hl	; AND NO PARAMETER BLOCKS ON THE STACK
	ld	(SUBFLG),a	; ALLOW SUBSCRIPTS
	push	hl	; PUT ZERO (NON $FOR,$GOSUB)
			; ON THE STACK
	push	bc	; PUT RETURN ADDRESS BACK ON
GTMPRT:	ld	hl,(TEMP)	; GET SAVED [H,L]
	ret

	PAGE
	SUBTTL	DCOMPR, SYNCHR - REPLACEMENTS FOR COMPAR & SYNCHK IN RSTLES VERSION
	PUBLIC	SYNCHR
DCOMPR:	ld	a,h	; REPLACEMENT FOR "COMPAR" RST
	sub	d
	ret	nz
	ld	a,l
	sub	e
	ret

SYNCHR:	ld	a,(hl)	; REPLACEMENT FOR "SYNCHK" RST
	ex	(sp),hl
	cp	(hl)
	jp	nz,SYNERR
	inc	hl
	ex	(sp),hl
	inc	hl	; LOOK AT NEXT CHAR
	ld	a,(hl)	; GET IT
	cp	':'	; IS IT END OF STATMENT OR BIGGER
	ret	nc
SYNCON:	jp	CHRCON	; REST OF CHRGET
SYNERR:	jp	SNERR
	SUBTTL	RESTORE, STOP, END

RESTOR:	ex	de,hl		; SAVE [H,L] IN [D,E]
	ld	hl,(TXTTAB)
	jp	z,BGNRST	; RESTORE DATA POINTER TO BEGINNING OF PROGRAM
	ex	de,hl		; TEXT POINTER BACK TO [H,L]
	call	LINGET	; GET THE FOLLOWING LINE NUMBER
	push	hl	; SAVE TEXT POINTER
	call	FNDLIN	; FIND THE LINE NUMBER
	ld	h,b	; GET POINTER TO LINE IN [H,L]
	ld	l,c
	pop	de	; TEXT POINTER BACK TO [D,E]
	jp	nc,USERR	; SHOULD HAVE FOUND LINE
BGNRST:	
	dec	hl	; INITIALIZE DATPTR TO [TXTTAB]-1
RESFIN:	ld	(DATPTR),hl	; READ FINISHES COME TO RESFIN
	ex	de,hl		; GET THE TEXT POINTER BACK
	ret
STOP:	ret	nz		; RETURN IF NOT CONTROL-C AND MAKE
			; SURE "STOP" STATEMENTS HAVE A TERMINATOR
STOPRG:	
	inc	a
	jp	CONSTP
			; TO TYPE THE BREAK MESSAGE
ENDS:	ret	nz		; MAKE SURE "END" STATEMENTS HAVE A TERMINATOR
	push	af	; PRESERVE CONDITION CODES OVER CALL TO CLSALL
	call	z,CLSALL
	pop	af	; RESTORE CONDITION CODES
CONSTP:	ld	(SAVTXT),hl	; SAVE FOR "CONTINUE"
	ld	hl,TEMPST	; RESET STRING TEMP POINTER
	ld	(TEMPPT),hl	; SAVE IN CASE ^C PRINT USING
	defb	0021h	; "LXI H," OVER NEXT TWO
STPEND:	or	0ffh	; SET NON-ZERO TO FORCE PRINTING OF BREAK MESSAGE
	pop	bc	; POP OFF NEWSTT ADDRESS
ENDCON:	ld	hl,(CURLIN)	; SAVE CURLIN
	push	hl	; SAVE LINE TO PRINT
	push	af	; SAVE THE MESSAGE FLAG
			; ZERO MEANS DON'T PRINT "BREAK"
	ld	a,l
	and	h	; SEE IF IT WAS DIRECT
	inc	a
	jp	z,DIRIS	; IF NOT SET UP FOR CONTINUE
	ld	(OLDLIN),hl	; SAVE OLD LINE #
	ld	hl,(SAVTXT)	; GET POINTER TO START OF STATEMENT
	ld	(OLDTXT),hl	; SAVE IT
DIRIS:	
	EXTRN	CNTOFL
	xor	a
	ld	(CNTOFL),a	; FORCE OUTPUT
	call	FINLPT
	call	CRDONZ	; PRINT CR IF TTYPOS .NE. 0
	pop	af	; GET BACK ^C FLAG
	ld	hl,BRKTXT	; "BREAK"
	jp	nz,ERRFIN	; CALL STROUT AND FALL INTO READY
	jp	STPRDY	; POP OFF LINE NUMBER & FALL INTO READY
	PAGE
	SUBTTL	CTRLPT, DDT, CONT, NULL, TRON, TROFF
	PUBLIC	CTRLPT,CTROPT
CTROPT:	ld	a,CONTO	; PRINT AN ^O.
CTRLPT:	push	af	; SAVE CURRENT CHAR
	sub	3	; CONTROL-C?
	jp	nz,NTCTCT	; NO
	EXTRN	PRTFLG
	ld	(PRTFLG),a	; DISPLAY ^C ONLY(NOT ON LPT)
	ld	(CNTOFL),a	; RESET ^O FLAG
NTCTCT:	
	ld	a,'^'	; PRINT UP-ARROW.
	call	OUTDO	; SEND IT
	pop	af	; GET BACK CONTROL CHAR.
	add	a,40h	; MAKE PRINTABLE
	call	OUTDO	; SEND IT
	jp	CRDO	; AND THEN SEND CRLF.
CONT:	ld	hl,(OLDTXT)	; A STORED TEXT POINTER OF
			; ZERO IS SETUP BY STKINI
			; AND INDICATES THERE IS NOTHING
			; TO CONTINUE
	ld	a,h	; "STOP","END",TYPING CRLF
	or	l	; TO "INPUT" AND ^C SETUP OLDTXT
RESERR:	ld	de,0+ERRCN	; "CAN'T CONTINUE"
	jp	z,ERROR
	ex	de,hl		; SAVE [H,L]
	ld	hl,(OLDLIN)
	ld	(CURLIN),hl	; SET UP OLD LINE # AS CURRENT LINE #
	ex	de,hl		; RESTORE [H,L]
	ret
	EXTRN	NULCNT
	PUBLIC	NULL
NULL:	call	GETBYT
	ret	nz		; MAKE SURE THERE IS A TERMINATOR
	inc	a	; CODE AT CRDO EXPECTS AT LEAST 1
	ld	(NULCNT),a	; CHANGE NUMBER OF NULLS
	ret
TON:	defb	003eh	; "MVI A," NON-ZERO QUANTITY
TOFF:	xor	a	; MAKE [A]=0 FOR NO TRACE
	ld	(TRCFLG),a	; UPDATE THE TRACE FLAG
	ret
	PAGE
	SUBTTL	SWAP, ERASE
	EXTRN	SWPTMP
	PUBLIC	SWAP
SWAP:	call	PTRGET	; [D,E]=POINTER AT VALUE #1
	push	de	; SAVE THE POINTER AT VALUE #1
	push	hl	; SAVE THE TEXT POINTER
	ld	hl,SWPTMP	; TEMPORARY STORE LOCATION
	call	VMOVE	; SWPTMP=VALUE #1
	ld	hl,(ARYTAB)	; GET ARYTAB SO CHANGE CAN BE NOTED
	ex	(sp),hl		; GET THE TEXT POINTER BACK
			; AND SAVE CURRENT [ARYTAB]
	call	GETYPR
	push	af	; SAVE THE TYPE OF VALUE #1
	call	SYNCHR
	defb	44	; MAKE SURE THE VARIABLES ARE
			; DELIMITED BY A COMMA
	call	PTRGET	; [D,E]=POINTER AT VALUE #2
	pop	bc	; [B]=TYPE OF VALUE #1
	call	GETYPR	; [A]=TYPE OF VALUE #2
	cp	b	; MAKE SURE THEY ARE THE SAME
	jp	nz,TMERR	; IF NOT, "TYPE MISMATCH" ERROR
	ex	(sp),hl		; [H,L]=OLD [ARYTAB] SAVE THE TEXT POINTER
	ex	de,hl		; [D,E]=OLD [ARYTAB]
	push	hl	; SAVE THE POINTER AT VALUE #2
	ld	hl,(ARYTAB)	; GET NEW [ARYTAB]
	call	DCOMPR
	jp	nz,FCERR	; IF ITS CHANGED, ERROR
	pop	de	; [D,E]=POINTER AT VALUE #2
	pop	hl	; [H,L]=TEXT POINTER
	ex	(sp),hl		; SAVE THE TEXT POINTER ON THE STACK
			; [H,L]=POINTER AT VALUE #1
	push	de	; SAVE THE POINTER AT VALUE #2
	call	VMOVE	; TRANSFER VALUE #2 INTO VALUE #1'S OLD
			; POSITION
	pop	hl	; [H,L]=POINTER AT VALUE #2
	ld	de,SWPTMP	; LOCATION OF VALUE #1
	call	VMOVE	; TRANSFER SWPTMP=VALUE #1 INTO VALUE #2'S
			; OLD POSITION
	pop	hl	; GET THE TEXT POINTER BACK
	ret
	PUBLIC	ERASE
ERASE:	
	ld	a,1
	ld	(SUBFLG),a	; THAT THIS IS "ERASE" CALLING PTRGET
	call	PTRGET	; GO FIND OUT WHERE TO ERASE
	jp	nz,FCERR	; PTRGET DID NOT FIND VARIABLE!
	push	hl	; SAVE THE TEXT POINTER
	ld	(SUBFLG),a	; ZERO OUT SUBFLG TO RESET "ERASE" FLAG
	ld	h,b	; [B,C]=START OF ARRAY TO ERASE
	ld	l,c
	dec	bc	; BACK UP TO THE FRONT
	dec	bc	; NO VALUE TYPE WITHOUT LENGTH=2
	dec	bc	; BACK UP ONE MORE
LPBKNM:	ld	a,(bc)	; GET A CHARACTER. ONLY THE COUNT HAS HIGH BIT=0
	dec	bc	; SO LOOP UNTIL WE SKIP OVER THE COUNT
	or	a	; SKIP ALL THE EXTRA CHARACTERS
	jp	m,LPBKNM
	dec	bc
	dec	bc
	add	hl,de	; [H,L]=THE END OF THIS ARRAY ENTRY
	ex	de,hl		; [D,E]=END OF THIS ARRAY
	ld	hl,(STREND)	; [H,L]=LAST LOCATION TO MOVE UP
ERSLOP:	call	DCOMPR	; SEE IF THE LAST LOCATION IS GOING TO BE MOVED
	ld	a,(de)	; DO THE MOVE
	ld	(bc),a
	inc	de	; UPDATE THE POINTERS
	inc	bc
	jp	nz,ERSLOP	; MOVE THE REST
	dec	bc
	ld	h,b	; SETUP THE NEW STORAGE END POINTER
	ld	l,c
	ld	(STREND),hl
	pop	hl	; GET BACK THE TEXT POINTER
	ld	a,(hl)	; SEE IF MORE ERASURES NEEDED
	cp	2ch	; ADDITIONAL VARIABLES DELIMITED BY COMMA
	ret	nz		; ALL DONE IF NOT
	call	CHRGTR
	jp	ERASE
CASDON:	
	PUBLIC	POPAHT
POPAHT:	pop	af
	pop	hl	; GET THE TEXT POINTER
	ret
	PAGE
;
;TEST FOR A LETTER / CARRY ON=NOT A LETTER
;		     CARRY OFF=A LETTER
;
ISLET:	ld	a,(hl)
ISLET2:	cp	'A'
	ret	c		; IF LESS THAN "A", RETURN EARLY
	cp	91	; 91="Z"+1
	ccf
	ret
	SUBTTL	CLEAR
;
; THIS CODE IS FOR THE "CLEAR" COMMAND WITH AN ARGUMENT
; TO CHANGE THE AMOUNT OF STRING SPACE ALLOCATED.
; IF NO FORMULA IS GIVEN THE AMOUNT OF STRING SPACE
; REMAINS UNCHANGED.
;
	PUBLIC	CLEAR
CLEAR:	jp	z,CLEARC	; IF NO FORMULA JUST CLEAR
	cp	2ch	; ALLOW NO STRING SPACE
	jp	z,CSKPCM
	call	INTID2	; GET AN INTEGER INTO [D,E]
	dec	hl
	call	CHRGTR	; SEE IF ITS THE END
	jp	z,CLEARC
CSKPCM:	call	SYNCHR
	defb	2ch
	jp	z,CLEARC
	ex	de,hl
	ld	hl,(TOPMEM)	; GET HIGHEST ADDRESS
	ex	de,hl
	cp	2ch
	jp	z,CLEARS	; SHOULD FINISH THERE
	call	FRMEVL	; EVALUATE FORMULA
	push	hl	; SAVE TEXT POINTER
	call	FRQINT	; CONVERT TO INTEGER IN [H,L]
	ld	a,h
	or	l	; Memory size =0?
	jp	z,FCERR##	; Yes, error
	ex	de,hl		; VALUE TO [D,E]
	pop	hl	; RESTORE TEXT POINTER
CLEARS:	dec	hl	; BACK UP
	call	CHRGTR	; GET CHAR
	push	de	; SAVE NEW HIGH MEM
	jp	z,CDFSTK	; USE SAME STACK SIZE
	call	SYNCHR
	defb	2ch
	jp	z,CDFSTK
	call	INTID2
	dec	hl
	call	CHRGTR
	jp	nz,SNERR
CLEART:	ex	(sp),hl		; SAVE TEXT POINTER
	push	hl	; SAVE CANDIDATE FOR TOPMEM
	ld	hl,0+(2*NUMLEV)+20	; CHECK STACK SIZE IS REASONABLE
	call	DCOMPR
	jp	nc,OMERR
	pop	hl
	call	SUBDE	; SUBTRACT [H,L]-[D,E] INTO [D,E]
	jp	c,OMERR	; WANTED MORE THAN TOTAL!
	push	hl	; SAVE MEMSIZ
	ld	hl,(VARTAB)	; TOP LOCATION IN USE
	ld	bc,0+20	; LEAVE BREATHING ROOM
	add	hl,bc
	call	DCOMPR	; ROOM?
	jp	nc,OMERR	; NO, DON'T EVEN CLEAR
	ex	de,hl		; NEW STACK LOCATION [H,L]
	ld	(MEMSIZ),hl	; SET UP NEW STACK LOCATION
	pop	hl	; GET BACK MEMSIZ
	ld	(TOPMEM),hl	; SET IT UP, MUST BE OK
	pop	hl	; REGAIN THE TEXT POINTER
	jp	CLEARC	; GO CLEAR
CDFSTK:	push	hl	; SAVE TEXT POINTER
	ld	hl,(TOPMEM)	; FIGURE OUT CURRENT STACK SIZE SO
	ex	de,hl		; IT IS SAVED
	ld	hl,(MEMSIZ)
	ld	a,e
	sub	l
	ld	e,a
	ld	a,d
	sbc	a,h
	ld	d,a
	pop	hl
	jp	CLEART

SUBDE:	ld	a,l
	sub	e
	ld	e,a
	ld	a,h
	sbc	a,d
	ld	d,a
	ret
	PAGE
	SUBTTL	NEXT CODE
;
; A "FOR" ENTRY ON THE STACK HAS THE FOLLOWING FORMAT:
;
; LOW ADDRESS
;	TOKEN ($FOR IN HIGH BYTE)  1 BYTES
;	A POINTER TO THE LOOP VARIABLE  2 BYTES
;	UNDER ANSI & LENGTH=2, TWO BYTES GIVING TEXT POINTER OF MATCHING "NEXT"
;	A BYTE REFLECTING THE SIGN OF THE INCREMENT 1 BYTE
;	UNDER LENGTH=2, A BYTE MINUS FOR INTEGER AND POSITIVE FOR FLOATING "FOR"S
;	THE STEP 4 BYTES
;	THE UPPER VALUE 4 BYTES
;	THE LINE # OF THE "FOR" STATEMENT 2 BYTES
;	A TEXT POINTER INTO THE "FOR" STATEMENT 2 BYTES
; HIGH ADDRESS
;
; TOTAL 16-19 BYTES
;
	PUBLIC	NEXT
NEXT:	
	push	af	; SAVE THE CHARACTER CODES
	defb	00f6h	; SET [A] NON-ZERO
	PUBLIC	NEXTS
NEXTS:	xor	a	; FLAG THAT "FOR" IS USING "NEXT"
	ld	(NXTFLG),a
	pop	af	; GET BACK THE CHARACTER CODE
	ld	de,0	; FOR THE "NEXT"
			; STATEMENT WITHOUT ANY ARGS
			; WE CALL FNDFOR WITH [D,E]=0
NEXTC:	
	EXTRN	NXTTXT
	ld	(NXTTXT),hl	; SAVE STARTING TEXT POINTER
	call	nz,PTRGET	; GET A POINTER TO THE
			; LOOP VARIABLE INTO [D,E]
	ld	(TEMP),hl	; PUT THE TEXT POINTER
			; IN A TEMP LOCATION
			; IN CASE THE LOOP TERMINATES
	call	FNDFOR	; TRY TO FIND A FOR ENTRY
			; ON THE STACK WHOSE VARIABLE NAME
			; MATCHES THIS ONES
	jp	nz,NFERR	; "NEXT WITHOUT FOR"
	ld	sp,hl		; SETUP STACK POINTER BY CHOPPING
			; AT THIS POINT
	push	de	; PUT THE VARIABLE PTR BACK ON
	ld	e,(hl)	; PICK UP THE CORRECT "NEXT" TEXT POINTER
	inc	hl
	ld	d,(hl)
	inc	hl
	push	hl	; SAVE THE POINTER INTO THE STACK ENTRY
	ld	hl,(NXTTXT)	; [H,L]=TEXT POINTER AT THE START OF THIS "NEXT"
	call	DCOMPR
	jp	nz,NFERR	; IF NO MATCH, "NEXT WITHOUT FOR"
	pop	hl
	pop	de	; GET BACK THE VARIABLE POINTER
	push	de
	ld	a,(hl)	; STEP ONTO THE STACK
	push	af
	inc	hl
	push	de	; PUT THE POINTER TO THE LOOP
			; VARIABLE ONTO THE STACK
	ld	a,(hl)	; GET FLAG WHETHER THIS IS AN INTEGER "FOR"
	inc	hl	; ADVANCE THE "FOR" ENTRY POINTER
	or	a	; SET THE MINUS FLAG IF IT'S AN INTEGER "FOR"
	jp	m,INTNXT	; HANDLE INTEGERS SEPERATELY
	call	MOVFM	; STEP VALUE INTO THE FAC
	ex	(sp),hl		; PUT THE POINTER INTO THE
			; FOR ENTRY ONTO THE STACK
	push	hl	; PUT THE POINTER TO THE LOOP
			; VARIABLE BACK ONTO THE STACK
	ld	a,(NXTFLG)	; IS "FOR" USING "NEXT"
	or	a
	jp	nz,NXTDO	; NO, CONTINUE "NEXT"
	EXTRN	FVALSV
	ld	hl,FVALSV	; FETCH THE INITIAL VALUE INTO THE FAC
	call	MOVFM
	xor	a	; CONTINUE THE "NEXT" WITH INITIAL VALUE
NXTDO:	call	nz,FADDS
	pop	hl	; POP OFF THE POINTER TO
			; THE LOOP VARIABLE
	call	MOVMF	; MOV FAC INTO LOOP VARIABLE
	pop	hl	; GET THE ENTRY POINTER
	call	MOVRM	; GET THE FINAL INTO THE REGISTERS
	push	hl	; SAVE THE ENTRY POINTER
	call	FCOMP	; COMPARE THE NUMBERS RETURNING 377 IF FAC IS
			; LESS THAN THE REGISTERS,
			; 0 IF EQUAL, OTHERWISE 1
	jp	FINNXT	; SKIP OVER INTEGER CODE
INTNXT:	inc	hl	; SKIP THE FOUR DUMMY BYTES
	inc	hl
	inc	hl
	inc	hl
	ld	c,(hl)	; [B,C]= THE STEP
	inc	hl
	ld	b,(hl)
	inc	hl
	ex	(sp),hl		; SAVE THE ENTRY POINTER ON THE STACK
			; AND SET [H,L]=POINTER TO THE LOOP VARIABLE
	ld	e,(hl)	; [D,E]=LOOP VARIABLE VALUE
	inc	hl
	ld	d,(hl)
	push	hl	; SAVE THE POINTER AT THE LOOP VARIABLE VALUE
	ld	l,c
	ld	h,b	; SETUP TO ADD [D,E] TO [H,L]
	ld	a,(NXTFLG)	; SEE IF "FOR" IS USING "NEXT"
	or	a
	jp	nz,INXTDO	; NO, JUST CONTINUE NEXT
	ld	hl,(FVALSV)	; GET THE INITIAL VALUE
	jp	IFORIN	; CONTINUE FIRST ITERATION CHECK
INXTDO:	call	IADD	; ADD THE STEP TO THE LOOP VARIABLE
	ld	a,(VALTYP)	; SEE IF THERE WAS OVERFLOW
	cp	4	; TURNED TO SINGLE-PRECISION?
	jp	z,OVERR	; INDICE GOT TOO LARGE
IFORIN:	ex	de,hl		; [D,E]=NEW LOOP VARIABLE VALUE
	pop	hl	; GET THE POINTER AT THE LOOP VARIABLE
	ld	(hl),d	; STORE THE NEW VALUE
	dec	hl
	ld	(hl),e
	pop	hl	; GET BACK THE POINTER INTO THE "FOR" ENTRY
	push	de	; SAVE THE VALUE OF THE LOOP VARIABLE
	ld	e,(hl)	; [D,E]=FINAL VALUE
	inc	hl
	ld	d,(hl)
	inc	hl
	ex	(sp),hl		; SAVE THE ENTRY POINTER AGAIN
			; GET THE VALUE OF THE LOOP VARIABLE INTO [H,L]
	call	ICOMP	; DO THE COMPARE
FINNXT:	
	pop	hl	; POP OFF THE "FOR" ENTRY POINTER WHICH IS NOW
			; POINTING PAST THE FINAL VALUE
	pop	bc	; GET THE SIGN OF THE INCREMENT
	sub	b	; SUBTRACT THE INCREMENTS SIGN FROM THAT
			; OF (CURRENT VALUE-FINAL VALUE)
	call	MOVRM	; GET LINE # OF "FOR" INTO [D,E]
			; GET TEXT POINTER OF "FOR" INTO [B,C]
	jp	z,LOOPDN	; IF SIGN(FINAL-CURRENT)+SIGN(STEP)=0
			; THEN THE LOOP IS FINISHED
	ex	de,hl
	ld	(CURLIN),hl	; STORE THE LINE #
	ld	l,c	; SETUP THE TEXT POINTER
	ld	h,b
	jp	NXTCON

LOOPDN:	ld	sp,hl		; ELIMINATE THE FOR ENTRY
			; SINCE [H,L] MOVED ALL
			; THE WAY DOWN THE ENTRY
	ld	(SAVSTK),hl	; UPDATE SAVED STACK
	ld	hl,(TEMP)	; RESTORE THE TEXT POINTER
	ld	a,(hl)	; IS THERE A COMMA AT THE END
	cp	44	; IF SO LOOK AT ANOTHER
	jp	nz,NEWSTT	; VARIABLE NAME TO "NEXT"
	call	CHRGTR	; READ FIRST CHARCTER
	call	NEXTC	; DO NEXT, BUT DON'T ALLOW
			; BLANK VARIABLE NAME [D,E]=STK PTR
			; AND WILL NEVER MATCH ANY VARPTR
			; USE CALL TO PUT DUMMY "NEWSTT" ENTRY ON
	PAGE
			; END I8086 CONDITONAL
	end

