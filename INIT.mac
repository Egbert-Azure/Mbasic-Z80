	.symlen 6
	SUBTTL	Common file for BASIC interpreter
	.SALL

CONTO	defl 15	; CHARACTER TO SUPRESS OUTPUT (USUALLY CONTROL-O)
DBLTRN	defl 0	; FOR DOUBLE PRECISION TRANSCENDENTALS
	IF2

	.printx	/EXTENDED/


	.printx	/LPT/

	.printx	/CPM DISK/


	.printx	/Z80/

	.printx	/FAST/

	.printx	/5.0 FEATURES/

	.printx	/ANSI COMPATIBLE/
	ENDIF

CLMWID	defl 14	; MAKE COMMA COLUMNS FOURTEEN CHARACTERS
DATPSC	defl 128	; NUMBER OF DATA BYTES IN DISK SECTOR
LINLN	defl 80	; TERMINAL LINE LENGTH
LPTLEN	defl 132
BUFLEN	defl 255	; LONG LINES
NAMLEN	defl 40	; MAXIMUM LENGTH NAME -- 3 TO 127

NUMLEV	defl 0*20+19+2*5	; NUMBER OF STACK LEVELS RESERVED
			; BY AN EXPLICIT CALL TO GETSTK

STRSIZ	defl 4

STRSIZ	defl 3
NUMTMP	defl 3	; NUMBER OF STRING TEMPORARIES

NUMTMP	defl 10

MD.RND	defl 3	; THE MODE NUMBER FOR RANDOM FILES
MD.SQI	defl 1	; THE MODE NUMBER FOR SEQUENTIAL INPUT FILES
			; NEVER WRITTEN INTO A FILE
MD.SQO	defl 2	; THE MODE FOR SEQUENTIAL OUTPUT FILES
			; AND PROGRAM FILES
CPMWRM	defl 0	; CP/M WARM BOOT ADDR
CPMENT	defl CPMWRM+5	; CP/M BDOS CALL ADDR
	CSEG
TRUROM	defl 0
	PAGE
	TITLE	INIT INITAILIZATION FOR BASIC 8080/Z80 GATES/ALLEN/DAVIDOFF
SWTCHR	defl 2fh	; DEFAULT SWITCH CHARACTER IS SLASH
	EXTRN	CNSGET
	EXTRN	CHRGTR
	EXTRN	OUTDO,LINPRT,MEMSIZ,CRDO,TXTTAB,OMERR
	EXTRN	REASON
	EXTRN	READY,STKINI,CURLIN,REPINI
	EXTRN	DCOMPR
	EXTRN	SYNCHR
	EXTRN	ERRFLG

	EXTRN	MAXFIL
	EXTRN	LPTPOS
	EXTRN	QINLIN,BUF,SNERR,FCERR,ATN,ATNFIX,COSFIX,TANFIX,SINFIX,COS
	PAGE
	SUBTTL	SYSTEM INITIALIZATION CODE
;THIS IS THE SYSTEM INITIALIZATION CODE
;IT SHOULD BE LOADED AT THE END OF THE BASIC
;INTERPRETER

	EXTRN	STROUT
	PUBLIC	TSTACK
	PUBLIC	INITSA,INIT
INITSA:	
	EXTRN	NODSKS
	call	NODSKS
	ld	hl,(TXTTAB)
	dec	hl
	ld	(hl),0
	EXTRN	LRUN
	ld	hl,(CPMFIL)	; POINT TO START OF COMMAND LINE
	ld	a,(hl)	; GET BYTE POINTED TO
	or	a	; IF ZERO, NO FILE SEEN
	jp	nz,LRUN	; TRY TO RUN FILE
	jp	READY
ENDIO:	defs	2, 0
INIT:	
	ld	hl,TSTACK	; SET UP TEMP STACK
	ld	sp,hl
	xor	a	; INITIALIZE PROTECT FLAG
	EXTRN	PROFLG
	ld	(PROFLG),a
	EXTRN	TOPMEM,FRETOP
	ld	(TOPMEM),hl
	EXTRN	SAVSTK
	ld	(SAVSTK),hl	; WE RESTORE STACK WHEN ERRORS
	ld	hl,(CPMWRM+1)	; GET START OF BIOS VECTOR TABLE
	ld	bc,0+4	; CSTS
	add	hl,bc	; ADD FOUR
	ld	e,(hl)	; PICK UP CSTS ADDRESS
	inc	hl
	ld	d,(hl)
	ex	de,hl		; GET CSTS ADDRESS
	ld	(CONST3##+1),hl	; THIRD CONTROL-C CHECK
	ld	(CONSTS##+1),hl	; SAVE
	ld	(CONST2##+1),hl	; FAST CONTROL-C CHECK
	ex	de,hl		; POINTER BACK TO [H,L]
	inc	hl	; POINT AT CI ADDRESS
	inc	hl
	ld	e,(hl)	; GET LOW BYTE OF CI ADDRESS
	inc	hl
	ld	d,(hl)	; GET HIGH BYTE
	ex	de,hl		; INPUT ADDRESS TO [H,L]
	ld	(CONIN##+1),hl	; SAVE IN CONSOLE INPUT CALL
	ex	de,hl		; POINTER BACK TO [H,L]
	inc	hl	; SKIP "JMP" OPCODE
	inc	hl	; BUMP POINTER
	ld	e,(hl)	; GET OUTPUT ROUTINE ADDRESS
	inc	hl
	ld	d,(hl)
	ex	de,hl		; INTO [H,L]
	ld	(CONOUT##+1),hl	; SAVE INTO OUTPUT ROUTINE
	ex	de,hl		; POINTER BACK TO [H,L]
	inc	hl	; NOW POINT TO PRINTER OUTPUT
	inc	hl	; ROUTINE ADDRESS
	ld	e,(hl)	; PICK IT UP
	inc	hl
	ld	d,(hl)
	ex	de,hl		; GET ADDRESS INTO [D,E]
	ld	(LPTOUT##+1),hl	; SET PRINT ROUTINE ADDRESS

;	Check CP/M Version Number

	EXTRN	CPMVRN,CPMREA,CPMWRI

	ld	c,12	; Version Test
	call	CPMENT
	ld	(CPMVRN),a	; [A] = Version Number (0 = 1.x)
	or	a	; Test version number
	ld	hl,21*256+20+0	; 1.x Read / Write
	jp	z,CPMVR1
	ld	hl,34*256+33+0	; 2.x Read / Write
CPMVR1:	ld	(CPMREA),hl	; Save Read/Write Codes
	ld	hl,0+65534	; SAY INITIALIZATION IS EXECUTING
	ld	(CURLIN),hl	; IN CASE OF ERROR MESSAGE
	EXTRN	CNTOFL
	xor	a
	ld	(CNTOFL),a
	EXTRN	ENDBUF
	ld	(ENDBUF),a	; MAKE SURE OVERRUNS STOP
	EXTRN	CHNFLG,MRGFLG
	ld	(CHNFLG),a	; MAKE SURE CHAINS AND MERGES
	ld	(MRGFLG),a	; DONT TRY TO HAPPEN
	ld	(ERRFLG),a	; DON'T ALLOW EDIT TO BE CALLED ON ERRORS
	ld	hl,0	; GET 0
	ld	(LPTPOS##),hl	; ZERO FLAG AND POSITION
	EXTRN	MAXREC
	ld	hl,0+128	; DEFAULT MAX REC SIZE
	ld	(MAXREC),hl
	EXTRN	TEMPST,TEMPPT
	ld	hl,TEMPST
	ld	(TEMPPT),hl
	EXTRN	PRMSTK,PRMPRV
	ld	hl,PRMSTK	; INITIALIZE PARAMETER BLOCK CHAIN
	ld	(PRMPRV),hl
	ld	hl,(CPMENT+1)	; GET LAST LOC IN MEMORY
	ld	(MEMSIZ),hl	; USE AS DEFAULT
;
;
; THE FOLLOWING CODE SCANS A CP/M COMMAND LINE FOR BASIC.
; THE FORMAT OF THE COMMAND IS:
;
; BASIC <FILE NAME>[/M:<TOPMEM>][/F:<FILES>]
;
;*
	ld	a,3	; DEFAULT FILES
	ld	(MAXFIL),a	; BY SETTING MAXFIL=3
	ld	hl,ZEROB	; POINT AT ZERO BYTE
	ld	(CPMFIL),hl	; SO IF RE-INITAILIZE OK
	ld	a,(COMAGN)	; HAVE WE ALREADY READ COMMAND LINE
	or	a	; AND GOT ERROR?
	jp	nz,ERRCMD	; THEN DEFAULT
	inc	a	; MAKE NON-ZERO
	ld	(COMAGN),a	; STORE BACK NON-ZERO FOR NEXT TIME
TBUFF	defl CPMWRM+128	; WHERE CP/M COMMAND BUFFER IS LOCATED

	ld	hl,TBUFF	; POINT TO FIRST CHAR OF COMMAND BUFFER
	ld	a,(hl)	; WHICH CONTAINS # OF CHARS IN COMMAND
	or	a	; IS THERE A COMMAND?
	ld	(CPMFIL),hl	; SAVE POINTER TO THIS ZERO
	jp	z,DONCMD	; NOTHING IN COMMAND BUFFER
	ld	b,(hl)	; AND [B]
	inc	hl	; POINT TO FIRST CHAR IN BUFFER
TBFLP:	ld	a,(hl)	; GET CHAR FROM BUFFER
	dec	hl	; BACK UP POINTER
	ld	(hl),a	; STORE CHAR BACK
	inc	hl	; NOW ADVANCE CHAR TO ONE PLACE
	inc	hl	; AFTER PREVIOUS POSIT.
	dec	b	; DECREMENT COUNT OF CHARS TO MOVE
	jp	nz,TBFLP	; KEEP MOVING CHARS
	dec	hl	; BACK UP POINTER
ENDCMD:	ld	(hl),0	; STORE TERMINATOR FOR CHRGET (0)
	ld	(CPMFIL),hl	; SAVE POINTER TO NEW ZERO (OLD DESTROYED)
	ld	hl,TBUFF-1	; POINT TO CHAR BEFORE BUFFER
	call	CHRGTR	; IGNORE LEADING SPACES
	or	a
	jp	z,DONCMD	; END OF COMMAND
	cp	SWTCHR	; IS IT A SLASH
	jp	z,FNDSLH	; YES
	dec	hl	; BACK UP POINTER
	ld	(hl),34	; STORE DOUBLE QUOTE
	ld	(CPMFIL),hl	; SAVE POINTER TO START OF FILE NAME
	inc	hl	; BUMP POINTER
ISSLH:	cp	SWTCHR	; OPTION?
	jp	z,FNDSLH	; YES
	call	CHRGTR	; SKIP OVER CHAR IN FILE NAME
	or	a	; SET CC'S
	jp	nz,ISSLH	; KEEP LOOKING FOR OPTION
	jp	DONCMD	; THATS EIT
FNDSLH:	ld	(hl),0	; STORE TERMINATOR OVER "/"
SCANSW:	call	CHRGTR	; GET CHAR AFTER SLASH
SCANS1:	
	cp	'S'	; IS IT /S: ? (SET MAX RECORD SIZE)
	jp	z,WASS	; YES
	cp	'M'	; MEMORY OPTION
	push	af	; SAVE INDICATOR
	jp	z,WASM	; WAS MEMORY OPTION
	cp	'F'	; FILES OPTION
	jp	nz,SNERR##	; NOT "M" OR "F" ERROR
WASM:	call	CHRGTR	; GET NEXT CHAR
	call	SYNCHR
	defb	':'	; COLON SHOULD FOLLOW
	call	CNSGET	; GET VALUE FOLLOWING COLON
	pop	af	; GET BACK M/F FLAG
	jp	z,MEM	; WAS MEMORY OPTION
	ld	a,d	; FILES CANT BE .GT. 255
	or	a	; SET CC'S
	jp	nz,FCERR##	; FUNCTION CALL ERROR
	ld	a,e	; GET LOW BYTE
	cp	16	; MUST BE .LT. 16
	jp	nc,FCERR##
	ld	(MAXFIL),a	; STORE IN # OF FILES
	jp	FOK	; DONE
MEM:	ex	de,hl		; PUT VALUE IN [D,E]
	ld	(MEMSIZ),hl	; SAVE INTO MEMSIZE
	ex	de,hl		; GET BACK TEXT POINTER
FOK:	dec	hl	; RESCAN LAST CHAR
	call	CHRGTR	; BY CALLING CHRGET
	jp	z,DONCMD	; END OF COMMAND
	call	SYNCHR
	defb	SWTCHR	; SLASH SHOULD FOLLOW
	jp	SCANS1	; SCAN NEXT SWITCH
WASS:	call	CHRGTR	; GET CHAR AFTER "S"
	call	SYNCHR
	defb	':'	; MAKE SURE COLON FOLLOWS
	call	CNSGET	; GET VALUE FOLLOWING COLON
	ex	de,hl		; SAVE IT
	ld	(MAXREC),hl
	ex	de,hl
	jp	FOK	; CONTINUE SCANNING
ZEROB:	defb	0	; ZERO BYTE
CPMFIL:	defs	2, 0	; POINTER TO BASIC LOAD FILE
COMAGN:	defb	0	; WE HAVENT SCANNED COMMAND YET
ERRCMD:	
DONCMD:	
ASKMEM:	
USEDEF:	dec	hl
	ld	hl,(MEMSIZ)	; GET SIZE OF MEMORY
	push	hl	; ALSO SAVE FOR LATER
			; SET UP DEFAULT STRING SPACE
	pop	hl
	dec	hl	; ALWAYS LEAVE TOP BYTE UNUSED BECAUSE
			; VAL(STRING) MAKES BYTE IN MEMORY
			; BEYOND LAST CHAR OF STRING=0
	ld	(MEMSIZ),hl	; SAVE IN REAL MEMORY SIZE
	dec	hl	; ONE LOWER IS STKTOP
	push	hl	; SAVE IT ON STACK



			; KEEP ALL FUNCTIONS

;
; DISK INITIALIZATION ROUTINE
; SETUP  FILE INFO BLOCKS
; THE NUMBER OF EACH AND INFORMATION FOR
; GETTING TO POINTERS TO EACH IS STORED. NO LOCATIONS ARE
; INITIALIZED, THIS IS DONE BY NODSKS, FIRST CLOSING ALL FILES.
; THE NUMBER OF FILES IS THE FILE POINTER TABLE
;
	PUBLIC	DSKDAT
DSKDAT	defl ENDIO	; START DATA AFTER ALL CODE
ASKSK:	
	ld	a,(MAXFIL)	; GET HIGHEST FILE #
	ld	hl,DSKDAT	; GET START OF MEMORY
	EXTRN	FILPT1,FILPTR,MAXFIL,DBLK.C
	ld	(FILPT1),hl
	ld	de,FILPTR	; POINT TO TABLE TO SET UP
	ld	(MAXFIL),a	; REMEMBER HOW MANY FILES
	inc	a	; ALWAYS FILE 0 FOR INTERNAL USE
	ld	bc,DBLK.C	; SIZE OF A FILE INFO BLOCK PLUS $CODE
LOPFLB:	ex	de,hl		; [H,L] POINT INTO POINTER BLOCK
	ld	(hl),e	; STORE THE POINTER AT THIS FILE
	inc	hl
	ld	(hl),d
	inc	hl
	ex	de,hl
	add	hl,bc	; [H,L] POINT TO NEXT INFO BLOCK
	EXTRN	FNZBLK
	push	hl	; SAVE [H,L]
	ld	hl,(MAXREC)	; GET MAX RECORD SIZE
	ld	bc,FNZBLK	; GET SIZE OF OTHER STUFF
	add	hl,bc
	ld	b,h
	ld	c,l	; RESULT TO [B,C]
	pop	hl	; RESTORE [H,L]
	dec	a	; ARE THERE MORE?
	jp	nz,LOPFLB
HAVFNS:			; TEXT ALWAYS PRECEDED BY ZERO
			; STORE IT
	inc	hl	; INCREMENT POINTER
	ld	(TXTTAB),hl	; SAVE BOTTOM OF MEMORY
	ld	(SAVSTK),hl	; WE RESTORE STACK WHEN ERRORS
	pop	de	; GET CURRENT MEMSIZ
	ld	a,e	; CALC TOTAL FREE/8
	sub	l
	ld	l,a
	ld	a,d
	sbc	a,h
	ld	h,a
	jp	c,OMERR
	ld	b,3	; DIVIDE BY 2 THREE TIMES
SHFLF3:	or	a
	ld	a,h
	rra
	ld	h,a
	ld	a,l
	rra
	ld	l,a
	dec	b
	jp	nz,SHFLF3
	ld	a,h	; SEE HOW MUCH
	cp	2	; IF LESS THAN 512 USE 1 EIGHTH
	jp	c,SMLSTK
	ld	hl,0+512
SMLSTK:	ld	a,e	; SUBTRACT STACK SIZE FROM TOP MEM
	sub	l
	ld	l,a
	ld	a,d
	sbc	a,h
	ld	h,a
	jp	c,OMERR
	ld	(MEMSIZ),hl
	ex	de,hl
	ld	(TOPMEM),hl
	ld	(FRETOP),hl	; REASON USES THIS...
	ld	sp,hl		; SET UP NEW STACK
	ld	(SAVSTK),hl
	ld	hl,(TXTTAB)
	ex	de,hl
	call	REASON
	ld	a,l	; SUBTRACT MEMSIZ-TXTTAB
	sub	e
	ld	l,a
	ld	a,h
	sbc	a,d
	ld	h,a
	dec	hl	; SINCE TWO ZEROS EXIST BETWEEN
	dec	hl	; TXTTAB AND STREND, ADJUST
	push	hl	; SAVE NUMBER OF BYTES TO PRINT
	ld	hl,HEDING	; GET HEADING ("BASIC VERSION...")
	call	STROUT	; PRINT IT
	pop	hl	; RESTORE NUMBER OF BYTES TO PRINT
	call	LINPRT	; PRINT # OF BYTES FREE
	ld	hl,WORDS	; TYPE THE HEADING
	call	STROUT	; "BYTES FREE"
	ld	hl,STROUT
	ld	(REPINI+1),hl
	call	CRDO	; PRINT CARRIAGE RETURN
	EXTRN	READYR
	ld	hl,READYR
	EXTRN	JMPINI
	ld	(JMPINI+1),hl
	jp	INITSA


AUTTXT:	defb	13
	defb	10
	defb	10
	defm	'Owned by Microsoft'
	defb	13
	defb	10
	defb	0


WORDS:	defm	' Bytes Free'
	defb	0
HEDING:	
	defb	26
	defm	'BASIC 5.2'
	defb	13
	defb	10



	defm	'MAGIC Operating System'
	defb	13
	defb	10
	defm	' Copyright 1982 (C)'
	defb	13,10
	defb	32,32,32,32,32
	defb	0
LASTWR::			; LAST WORD OF SYSTEM CODE+1
	defs	70+300*0+200*0+30*0, 0	; SPACE FOR TEMP STACK
TSTACK:	
			; MAKE SURE LAST WORD PUNCHED IS OK
	end

